[
  {
    "id": 33,
    "title": "Search in Rotated Sorted Array",
    "description": "There is an integer array **nums** sorted in ascending order (with distinct values). Prior to being passed to your function, **nums** is possibly rotated at an unknown pivot index `k` (1 <= k < nums.length) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (0-indexed).\n\nGiven the array **nums** after the possible rotation and an integer **target**, return the index of **target** if it is in **nums**, or `-1` if it is not in **nums**.\n\nYou must write an algorithm with `O(log n)` runtime complexity.",
    "input_format": "First line: An integer N representing the size of the array.\nSecond line: N space-separated integers representing the array nums.\nThird line: An integer target.",
    "output_format": "Print the index of the target, or -1 if not found.",
    "difficulty": "Medium",
    "tags": [
      "array",
      "binary_search"
    ],
    "solution": "### Observations\nThe array is sorted but rotated. This means if we split the array into two halves at the middle, at least one half will always be sorted.\n\n### Approach\n1. Use standard Binary Search with `low` and `high`.\n2. Calculate `mid`.\n3. Check if `nums[mid]` is the target.\n4. If not, identify which half is sorted:\n   - If `nums[low] <= nums[mid]`, the left half is sorted.\n   - Otherwise, the right half is sorted.\n5. Check if the target lies within the range of the sorted half.\n   - If yes, eliminate the other half.\n   - If no, search in the unsorted half.\n\n### Complexity Analysis\n- **Time:** O(log N)\n- **Space:** O(1)\n\n### Code Logic\n```python\nwhile low <= high:\n    mid = (low + high) // 2\n    if nums[mid] == target:\n        return mid\n    if nums[low] <= nums[mid]: # Left half sorted\n        if nums[low] <= target < nums[mid]:\n            high = mid - 1\n        else:\n            low = mid + 1\n    else: # Right half sorted\n        if nums[mid] < target <= nums[high]:\n            low = mid + 1\n        else:\n            high = mid - 1\nreturn -1\n```",
    "hints": [
      "The array is rotated, but one half (left or right) is always sorted.",
      "Use Binary Search. Determine which side is sorted by comparing nums[low] and nums[mid].",
      "If the left side is sorted, check if the target lies within the range [nums[low], nums[mid]].",
      "If the right side is sorted, check if the target lies within the range [nums[mid], nums[high]]."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    # Read N\n    try:\n        line1 = sys.stdin.readline()\n        if not line1:\n            return\n        n = int(line1.strip())\n        \n        # Read Array\n        line2 = sys.stdin.readline()\n        if not line2:\n            return\n        nums = list(map(int, line2.strip().split()))\n        \n        # Read Target\n        line3 = sys.stdin.readline()\n        if not line3:\n            return\n        target = int(line3.strip())\n        \n        # Write your solution here\n        \n    except ValueError:\n        return\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (sc.hasNextInt()) {\n            int n = sc.nextInt();\n            int[] nums = new int[n];\n            for(int i=0; i<n; i++) {\n                nums[i] = sc.nextInt();\n            }\n            int target = sc.nextInt();\n            \n            // Call your solution function here\n        }\n    }\n}",
    "test_cases": [
      {
        "input_data": "7\n4 5 6 7 0 1 2\n0",
        "expected_output": "4",
        "is_public": true
      },
      {
        "input_data": "7\n4 5 6 7 0 1 2\n3",
        "expected_output": "-1",
        "is_public": true
      },
      {
        "input_data": "1\n1\n0",
        "expected_output": "-1",
        "is_public": false
      },
      {
        "input_data": "1\n1\n1",
        "expected_output": "0",
        "is_public": false
      },
      {
        "input_data": "3\n3 1 2\n2",
        "expected_output": "2",
        "is_public": false
      },
      {
        "input_data": "5\n3 1\n3",
        "expected_output": "0",
        "is_public": false
      }
    ]
  },
  {
    "id": 4,
    "title": "Median of Two Sorted Arrays",
    "description": "Given two sorted arrays **nums1** and **nums2** of size `m` and `n` respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be `O(log (m+n))`.",
    "input_format": "First line: Two integers M and N.\nSecond line: M integers for nums1.\nThird line: N integers for nums2.",
    "output_format": "Print the median value as a float (formatted to usually 5 decimal places if needed, but standard print is fine).",
    "difficulty": "Hard",
    "tags": [
      "array",
      "binary_search"
    ],
    "solution": "### Observations\nMerging arrays takes O(m+n), which is too slow. We need O(log(min(m,n))). The median divides the combined set into two equal halves.\n\n### Approach\n1. Ensure `nums1` is the smaller array to minimize binary search range.\n2. Binary search on the partition index of `nums1`.\n3. Calculate the partition index for `nums2` based on the total elements needed in the left half.\n4. Check if the partition is valid:\n   - `maxLeft1 <= minRight2`\n   - `maxLeft2 <= minRight1`\n5. If valid, calculate median based on total length (odd or even).\n6. If invalid, adjust binary search pointers.\n\n### Complexity Analysis\n- **Time:** O(log(min(m, n)))\n- **Space:** O(1)\n\n### Code Logic\n```python\nA, B = nums1, nums2\ntotal = len(A) + len(B)\nhalf = total // 2\n\nif len(B) < len(A):\n    A, B = B, A\n\nl, r = 0, len(A) - 1\nwhile True:\n    i = (l + r) // 2\n    j = half - i - 2\n    \n    Aleft = A[i] if i >= 0 else float('-inf')\n    Aright = A[i+1] if (i+1) < len(A) else float('inf')\n    Bleft = B[j] if j >= 0 else float('-inf')\n    Bright = B[j+1] if (j+1) < len(B) else float('inf')\n    \n    if Aleft <= Bright and Bleft <= Aright:\n        if total % 2:\n            return min(Aright, Bright)\n        return (max(Aleft, Bleft) + min(Aright, Bright)) / 2\n    elif Aleft > Bright:\n        r = i - 1\n    else:\n        l = i + 1\n```",
    "hints": [
      "Don't merge the arrays; that is O(M+N). Use Binary Search.",
      "Perform Binary Search on the smaller array to cut time complexity.",
      "Try to find a partition such that all elements on the left are smaller than all elements on the right.",
      "The partition split is valid when max(left_part) <= min(right_part)."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    try:\n        line1 = sys.stdin.readline()\n        if not line1: return\n        m, n = map(int, line1.split())\n        \n        line2 = sys.stdin.readline()\n        nums1 = list(map(int, line2.split())) if line2.strip() else []\n        \n        line3 = sys.stdin.readline()\n        nums2 = list(map(int, line3.split())) if line3.strip() else []\n        \n        # Logic here\n        \n    except ValueError: return\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if(sc.hasNextInt()) {\n            int m = sc.nextInt();\n            int n = sc.nextInt();\n            int[] nums1 = new int[m];\n            int[] nums2 = new int[n];\n            for(int i=0; i<m; i++) nums1[i] = sc.nextInt();\n            for(int i=0; i<n; i++) nums2[i] = sc.nextInt();\n            \n            // Logic here\n        }\n    }\n}",
    "test_cases": [
      {
        "input_data": "2 1\n1 3\n2",
        "expected_output": "2.0",
        "is_public": true
      },
      {
        "input_data": "2 2\n1 2\n3 4",
        "expected_output": "2.5",
        "is_public": true
      },
      {
        "input_data": "0 1\n\n1",
        "expected_output": "1.0",
        "is_public": false
      },
      {
        "input_data": "2 2\n100 101\n1 2",
        "expected_output": "51.0",
        "is_public": false
      },
      {
        "input_data": "1 1\n1\n2",
        "expected_output": "1.5",
        "is_public": false
      },
      {
        "input_data": "3 3\n1 2 3\n1 2 3",
        "expected_output": "2.0",
        "is_public": false
      }
    ]
  },
  {
    "id": 410,
    "title": "Split Array Largest Sum",
    "description": "Given an integer array **nums** and an integer **k**, split **nums** into **k** non-empty subarrays such that the largest sum of any subarray is minimized.\n\nReturn the minimized largest sum of the split.",
    "input_format": "First line: Two integers N and K.\nSecond line: N integers representing the array nums.",
    "output_format": "Print the integer result representing the minimized largest sum.",
    "difficulty": "Hard",
    "tags": [
      "binary_search",
      "array"
    ],
    "solution": "### Observations\nThis is a classic 'Min-Max' problem. We are looking for a value `X` such that we can split the array into `k` parts where no part sums to more than `X`.\n\n### Approach\n1. Use Binary Search on the Answer space.\n2. **Range:** The smallest possible max sum is `max(nums)` (each element is a split). The largest is `sum(nums)` (one split).\n3. **Check Function:** Can we split the array into `<= k` subarrays such that no subarray sum exceeds `mid`?\n   - Iterate greedily; add numbers to current sum.\n   - If adding a number exceeds `mid`, start a new subarray and increment count.\n4. If valid, try a smaller sum (`high = mid - 1`). If not, need a larger sum (`low = mid + 1`).\n\n### Complexity Analysis\n- **Time:** O(N * log(Sum - Max))\n- **Space:** O(1)\n\n### Code Logic\n```python\ndef can_split(largest_sum):\n    splits = 1\n    curr_sum = 0\n    for n in nums:\n        curr_sum += n\n        if curr_sum > largest_sum:\n            splits += 1\n            curr_sum = n\n    return splits <= k\n\nlow, high = max(nums), sum(nums)\nres = high\nwhile low <= high:\n    mid = (low + high) // 2\n    if can_split(mid):\n        res = mid\n        high = mid - 1\n    else:\n        low = mid + 1\nreturn res\n```",
    "hints": [
      "Think about the range of possible answers. What is the lower bound and upper bound?",
      "Lower bound is the maximum single element (cannot split smaller than that). Upper bound is the sum of all elements.",
      "Use Binary Search on this range of sums.",
      "Write a greedy function to check if a specific sum cap is feasible with K splits."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    lines = sys.stdin.read().split()\n    if not lines: return\n    \n    iterator = iter(lines)\n    try:\n        n = int(next(iterator))\n        k = int(next(iterator))\n        nums = []\n        for _ in range(n):\n            nums.append(int(next(iterator)))\n        \n        # Logic here\n            \n    except StopIteration:\n        return\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if(sc.hasNextInt()) {\n            int n = sc.nextInt();\n            int k = sc.nextInt();\n            int[] nums = new int[n];\n            for(int i=0; i<n; i++) nums[i] = sc.nextInt();\n            \n            // Logic here\n        }\n    }\n}",
    "test_cases": [
      {
        "input_data": "5 2\n7 2 5 10 8",
        "expected_output": "18",
        "is_public": true
      },
      {
        "input_data": "5 2\n1 2 3 4 5",
        "expected_output": "9",
        "is_public": true
      },
      {
        "input_data": "5 5\n1 2 3 4 5",
        "expected_output": "5",
        "is_public": false
      },
      {
        "input_data": "5 1\n1 2 3 4 5",
        "expected_output": "15",
        "is_public": false
      },
      {
        "input_data": "3 3\n100 100 100",
        "expected_output": "100",
        "is_public": false
      },
      {
        "input_data": "4 2\n1 1 1 100",
        "expected_output": "100",
        "is_public": false
      }
    ]
  },
  {
    "id": 875,
    "title": "Koko Eating Bananas",
    "description": "Koko loves to eat bananas. There are `n` piles of bananas, the `i-th` pile has `piles[i]` bananas. The guards have gone and will come back in `h` hours.\n\nKoko can decide her bananas-per-hour eating speed of `k`. Each hour, she chooses some pile of bananas and eats `k` bananas from that pile. If the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.\n\nReturn the minimum integer `k` such that she can eat all the bananas within `h` hours.",
    "input_format": "First line: Two integers N and H.\nSecond line: N integers representing the piles.",
    "output_format": "Print the minimum eating speed k.",
    "difficulty": "Medium",
    "tags": [
      "binary_search",
      "array"
    ],
    "solution": "### Observations\nIf Koko can eat all bananas at speed `k`, she can also eat them at speed `k+1`. This monotonicity suggests Binary Search on the answer.\n\n### Approach\n1. **Range:** Speed can be from `1` to `max(piles)`.\n2. **Check Function:** For a given speed `k`, calculate total hours needed.\n   - Hours for a pile `p` = `ceil(p / k)`.\n   - In integer arithmetic: `(p + k - 1) // k`.\n3. If `hours_needed <= h`, `k` is valid. Try to find a smaller `k` (move left).\n4. Otherwise, speed is too slow. Increase `k` (move right).\n\n### Complexity Analysis\n- **Time:** O(N * log(Max_Pile))\n- **Space:** O(1)\n\n### Code Logic\n```python\nimport math\n\nl, r = 1, max(piles)\nres = r\n\nwhile l <= r:\n    k = (l + r) // 2\n    hours = 0\n    for p in piles:\n        hours += (p + k - 1) // k\n    \n    if hours <= h:\n        res = k\n        r = k - 1\n    else:\n        l = k + 1\nreturn res\n```",
    "hints": [
      "If Koko eats at speed K, how many hours does it take to finish a pile of size P? It takes ceil(P/K).",
      "The possible speeds range from 1 to max(piles).",
      "Use Binary Search to find the minimum speed.",
      "Be careful with integer division. ceil(x/y) is (x + y - 1) // y."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    lines = sys.stdin.read().split()\n    if not lines: return\n    iterator = iter(lines)\n    try:\n        n = int(next(iterator))\n        h = int(next(iterator))\n        piles = []\n        for _ in range(n):\n            piles.append(int(next(iterator)))\n        \n        # Logic here\n            \n    except StopIteration: return\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if(sc.hasNextInt()) {\n            int n = sc.nextInt();\n            int h = sc.nextInt();\n            int[] piles = new int[n];\n            for(int i=0; i<n; i++) piles[i] = sc.nextInt();\n            \n            // Logic here\n        }\n    }\n}",
    "test_cases": [
      {
        "input_data": "4 8\n3 6 7 11",
        "expected_output": "4",
        "is_public": true
      },
      {
        "input_data": "5 5\n30 11 23 4 20",
        "expected_output": "30",
        "is_public": true
      },
      {
        "input_data": "5 6\n30 11 23 4 20",
        "expected_output": "23",
        "is_public": true
      },
      {
        "input_data": "3 1000\n1 1 1",
        "expected_output": "1",
        "is_public": false
      },
      {
        "input_data": "1 2\n10",
        "expected_output": "5",
        "is_public": false
      },
      {
        "input_data": "1 1\n1000000000",
        "expected_output": "1000000000",
        "is_public": false
      }
    ]
  },
  {
    "id": 162,
    "title": "Find Peak Element",
    "description": "A peak element is an element that is strictly greater than its neighbors.\n\nGiven a **0-indexed** integer array **nums**, find a peak element, and return its index. If the array contains multiple peaks, return the index to **any of the peaks**.\n\nYou may imagine that `nums[-1] = nums[n] = -âˆž`. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\n\nYou must write an algorithm that runs in `O(log n)` time.",
    "input_format": "First line: Integer N.\nSecond line: N integers for the array.",
    "output_format": "Print the index of any peak element.",
    "difficulty": "Medium",
    "tags": [
      "array",
      "binary_search"
    ],
    "solution": "### Observations\nSince we want `O(log n)` and the array is unsorted, but we need to find a local maximum, we can use the slope property.\n\n### Approach\n1. Use Binary Search.\n2. Calculate `mid`.\n3. Compare `nums[mid]` with `nums[mid + 1]`.\n4. If `nums[mid] < nums[mid + 1]`, we are on an upward slope. A peak must exist to the right (since the right end is -infinity). Move `low = mid + 1`.\n5. If `nums[mid] > nums[mid + 1]`, we are on a downward slope. A peak must exist to the left (or be `mid` itself). Move `high = mid`.\n\n### Complexity Analysis\n- **Time:** O(log N)\n- **Space:** O(1)\n\n### Code Logic\n```python\nl, r = 0, len(nums) - 1\nwhile l < r:\n    mid = (l + r) // 2\n    if nums[mid] > nums[mid + 1]:\n        r = mid\n    else:\n        l = mid + 1\nreturn l\n```",
    "hints": [
      "Think of the array as a mountain landscape.",
      "If nums[mid] < nums[mid+1], then you are climbing up. The peak must be to the right.",
      "If nums[mid] > nums[mid+1], you are going down. The peak is to the left or at mid.",
      "Binary search can discard half the array based on slope."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    try:\n        line1 = sys.stdin.readline()\n        if not line1: return\n        n = int(line1.strip())\n        \n        line2 = sys.stdin.readline()\n        if not line2: return\n        nums = list(map(int, line2.strip().split()))\n        \n        # Logic here\n        \n    except ValueError: return\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if(sc.hasNextInt()) {\n            int n = sc.nextInt();\n            int[] nums = new int[n];\n            for(int i=0; i<n; i++) nums[i] = sc.nextInt();\n            \n            // Logic here\n        }\n    }\n}",
    "test_cases": [
      {
        "input_data": "4\n1 2 3 1",
        "expected_output": "2",
        "is_public": true
      },
      {
        "input_data": "7\n1 2 1 3 5 6 4",
        "expected_output": "5",
        "is_public": true
      },
      {
        "input_data": "1\n1",
        "expected_output": "0",
        "is_public": false
      },
      {
        "input_data": "2\n1 2",
        "expected_output": "1",
        "is_public": false
      },
      {
        "input_data": "2\n2 1",
        "expected_output": "0",
        "is_public": false
      },
      {
        "input_data": "3\n1 5 1",
        "expected_output": "1",
        "is_public": false
      }
    ]
  }
]