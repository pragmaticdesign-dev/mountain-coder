[
    {
  "id": 55,
  "title": "Jump Game",
  "description": "You are given an integer array **nums**. You are initially positioned at the array's **first index**.\n\nEach element in the array represents your maximum jump length at that position.\n\nReturn `true` if you can reach the last index, or `false` otherwise.",
  "input_format": "First line: An integer N representing the size of the array.\nSecond line: N space-separated integers representing the array nums.",
  "output_format": "A single string \"true\" or \"false\".",
  "difficulty": "Medium",
  "tags": [
    "array",
    "dp",
    "greedy"
  ],
  "solution": "### Observations\nThis looks like a dynamic programming problem where `dp[i]` indicates if index `i` is reachable. However, that requires $O(N^2)$. We can optimize this by noticing that we only care about the **maximum reachable index** at any point.\n\n### Approach: Greedy\n1.  Initialize a variable `max_reachable` to 0.\n2.  Iterate through the array with index `i`.\n3.  If `i` is greater than `max_reachable`, it means we cannot reach this index from any previous jump. Return `false`.\n4.  Update `max_reachable = max(max_reachable, i + nums[i])`.\n5.  If `max_reachable` is greater than or equal to the last index (`n - 1`), return `true`.\n\n### Complexity Analysis\n* **Time Complexity:** $O(N)$. We iterate through the array once.\n* **Space Complexity:** $O(1)$. We only use a few variables.\n\n### Code Logic\n\n**Python Logic**\n```python\nmax_reachable = 0\nfor i, jump in enumerate(nums):\n    if i > max_reachable:\n        return False\n    max_reachable = max(max_reachable, i + jump)\n    if max_reachable >= len(nums) - 1:\n        return True\nreturn True\n```",
  "hints": [
    "You don't need to calculate every possible path.",
    "Try to keep track of the furthest index you can reach from your current position.",
    "If you are at index `i` and the furthest you can reach is less than `i`, then you can never reach `i`.",
    "Greedily update the maximum reach at every step."
  ],
  "boilerplate_python": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n\n    iterator = iter(input_data)\n    try:\n        n = int(next(iterator))\n        nums = []\n        for _ in range(n):\n            nums.append(int(next(iterator)))\n    except StopIteration:\n        return\n\n    # Write your code here\n    # result = ...\n\n    # print(\"true\" if result else \"false\")\n\nif __name__ == '__main__':\n    solve()",
  "boilerplate_java": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line = br.readLine();\n        if (line == null) return;\n        int n = Integer.parseInt(line.trim());\n        \n        int[] nums = new int[n];\n        String[] parts = br.readLine().trim().split(\"\\\\s+\");\n        for(int i=0; i<n; i++) {\n            nums[i] = Integer.parseInt(parts[i]);\n        }\n        \n        // Write logic here\n        // boolean result = ...\n        \n        // System.out.println(result ? \"true\" : \"false\");\n    }\n}",
  "test_cases": [
    {
      "input_data": "5\n2 3 1 1 4",
      "expected_output": "true",
      "is_public": true
    },
    {
      "input_data": "5\n3 2 1 0 4",
      "expected_output": "false",
      "is_public": true
    },
    {
      "input_data": "1\n0",
      "expected_output": "true",
      "is_public": false
    },
    {
      "input_data": "2\n0 2",
      "expected_output": "false",
      "is_public": false
    },
    {
      "input_data": "4\n1 2 3 0",
      "expected_output": "true",
      "is_public": false
    },
    {
      "input_data": "6\n5 4 0 2 0 1",
      "expected_output": "true",
      "is_public": false
    },
    {
      "input_data": "7\n1 1 1 1 1 1 1",
      "expected_output": "true",
      "is_public": false
    },
    {
      "input_data": "4\n1 0 1 0",
      "expected_output": "false",
      "is_public": false
    }
  ]
},
{
  "id": 322,
  "title": "Coin Change",
  "description": "You are given an integer array **coins** representing coins of different denominations and an integer **amount** representing a total amount of money.\n\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return `-1`.\n\nYou may assume that you have an infinite number of each kind of coin.",
  "input_format": "First line: An integer N (number of coin types).\nSecond line: N space-separated integers representing the coins.\nThird line: An integer 'amount'.",
  "output_format": "A single integer representing the minimum number of coins or -1.",
  "difficulty": "Medium",
  "tags": [
    "array",
    "dp",
    "bfs"
  ],
  "solution": "### Observations\nWe want to minimize the number of coins. A greedy approach (always taking the largest coin) fails here (e.g., coins=[1,3,4], amount=6; Greedy gives 4+1+1=3 coins, but Optimal is 3+3=2 coins). This suggests Dynamic Programming or BFS.\n\n### Approach: Dynamic Programming (Bottom-Up)\n1.  Create an array `dp` of size `amount + 1`, initialized to `amount + 1` (a value larger than any possible solution). Set `dp[0] = 0`.\n2.  Iterate through every amount `a` from 1 to `amount`.\n3.  For each coin `c` in `coins`:\n    * If `a - c >= 0`, we can potentially form amount `a` by adding one coin `c` to the optimal solution for `a - c`.\n    * `dp[a] = min(dp[a], 1 + dp[a - c])`.\n4.  If `dp[amount]` is still `amount + 1`, it means the amount cannot be formed. Return -1. Otherwise, return `dp[amount]`.\n\n### Complexity Analysis\n* **Time Complexity:** $O(S \\times N)$, where $S$ is the amount and $N$ is the number of coin denominations.\n* **Space Complexity:** $O(S)$ for the DP table.\n\n### Code Logic\n\n**Python Logic**\n```python\ndp = [float('inf')] * (amount + 1)\ndp[0] = 0\n\nfor a in range(1, amount + 1):\n    for c in coins:\n        if a - c >= 0:\n            dp[a] = min(dp[a], 1 + dp[a - c])\n\nreturn dp[amount] if dp[amount] != float('inf') else -1\n```",
  "hints": [
    "This is a classic Dynamic Programming problem.",
    "Define dp[i] as the minimum number of coins needed to make amount i.",
    "To calculate dp[i], look at dp[i - coin_value] for all coin values.",
    "Initialize your DP array with a value slightly larger than the maximum possible amount so you can use the min() function effectively."
  ],
  "boilerplate_python": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n\n    iterator = iter(input_data)\n    try:\n        n = int(next(iterator))\n        coins = []\n        for _ in range(n):\n            coins.append(int(next(iterator)))\n        amount = int(next(iterator))\n    except StopIteration:\n        return\n\n    # Write your code here\n    # result = ...\n\n    # print(result)\n\nif __name__ == '__main__':\n    solve()",
  "boilerplate_java": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line = br.readLine();\n        if (line == null) return;\n        int n = Integer.parseInt(line.trim());\n        \n        int[] coins = new int[n];\n        String[] parts = br.readLine().trim().split(\"\\\\s+\");\n        for(int i=0; i<n; i++) {\n            coins[i] = Integer.parseInt(parts[i]);\n        }\n        \n        String amtLine = br.readLine();\n        if (amtLine == null) return;\n        int amount = Integer.parseInt(amtLine.trim());\n        \n        // Write logic here\n        // int result = ...\n        \n        // System.out.println(result);\n    }\n}",
  "test_cases": [
    {
      "input_data": "3\n1 2 5\n11",
      "expected_output": "3",
      "is_public": true
    },
    {
      "input_data": "1\n2\n3",
      "expected_output": "-1",
      "is_public": true
    },
    {
      "input_data": "1\n1\n0",
      "expected_output": "0",
      "is_public": true
    },
    {
      "input_data": "3\n1 3 4\n6",
      "expected_output": "2",
      "is_public": false
    },
    {
      "input_data": "2\n2 5\n10",
      "expected_output": "2",
      "is_public": false
    },
    {
      "input_data": "3\n186 419 83\n6249",
      "expected_output": "20",
      "is_public": false
    },
    {
      "input_data": "4\n1 2 5 10\n18",
      "expected_output": "4",
      "is_public": false
    }
  ]
},
{
  "id": 134,
  "title": "Gas Station",
  "description": "There are `n` gas stations along a circular route, where the amount of gas at the `i-th` station is **gas[i]**.\n\nYou have a car with an unlimited gas tank and it costs **cost[i]** of gas to travel from the `i-th` station to its next `(i + 1)-th` station. You begin the journey with an empty tank at one of the gas stations.\n\nGiven two integer arrays `gas` and `cost`, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return `-1`. If there exists a solution, it is guaranteed to be **unique**.",
  "input_format": "First line: An integer N.\nSecond line: N space-separated integers for gas.\nThird line: N space-separated integers for cost.",
  "output_format": "A single integer representing the starting index or -1.",
  "difficulty": "Medium",
  "tags": [
    "array",
    "greedy"
  ],
  "solution": "### Observations\n1.  If sum(gas) < sum(cost), it's impossible to complete the circuit. Return -1 immediately.\n2.  If the total gas is sufficient, there must be a solution.\n\n### Approach: Greedy\n1.  Initialize `total_tank` (to check validity) and `curr_tank` (to find start index) to 0.\n2.  Initialize `start_index` to 0.\n3.  Iterate through the stations:\n    * Update `total_tank` and `curr_tank` by adding `gas[i] - cost[i]`.\n    * If `curr_tank` drops below 0, it means we cannot reach station `i` from the current `start_index`. Therefore, the starting station must be after `i`. Reset `start_index` to `i + 1` and reset `curr_tank` to 0.\n4.  Return `start_index` if `total_tank >= 0`, else -1.\n\n### Complexity Analysis\n* **Time Complexity:** $O(N)$. Single pass.\n* **Space Complexity:** $O(1)$.\n\n### Code Logic\n\n**Python Logic**\n```python\nif sum(gas) < sum(cost):\n    return -1\n\nstart, curr_tank = 0, 0\nfor i in range(len(gas)):\n    curr_tank += gas[i] - cost[i]\n    if curr_tank < 0:\n        start = i + 1\n        curr_tank = 0\nreturn start\n```",
  "hints": [
    "Check if the total gas is at least the total cost. If not, return -1 immediately.",
    "If you start at station A and get stuck at station B, then no station between A and B can be a valid starting point.",
    "Keep a running total of gas balance. If it drops below zero, reset your starting point to the next station."
  ],
  "boilerplate_python": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n\n    iterator = iter(input_data)\n    try:\n        n = int(next(iterator))\n        gas = []\n        for _ in range(n):\n            gas.append(int(next(iterator)))\n        cost = []\n        for _ in range(n):\n            cost.append(int(next(iterator)))\n    except StopIteration:\n        return\n\n    # Write your code here\n    # result = ...\n\n    # print(result)\n\nif __name__ == '__main__':\n    solve()",
  "boilerplate_java": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line = br.readLine();\n        if (line == null) return;\n        int n = Integer.parseInt(line.trim());\n        \n        int[] gas = new int[n];\n        String[] partsGas = br.readLine().trim().split(\"\\\\s+\");\n        for(int i=0; i<n; i++) gas[i] = Integer.parseInt(partsGas[i]);\n        \n        int[] cost = new int[n];\n        String[] partsCost = br.readLine().trim().split(\"\\\\s+\");\n        for(int i=0; i<n; i++) cost[i] = Integer.parseInt(partsCost[i]);\n        \n        // Write logic here\n        // int result = ...\n        \n        // System.out.println(result);\n    }\n}",
  "test_cases": [
    {
      "input_data": "5\n1 2 3 4 5\n3 4 5 1 2",
      "expected_output": "3",
      "is_public": true
    },
    {
      "input_data": "3\n2 3 4\n3 4 3",
      "expected_output": "-1",
      "is_public": true
    },
    {
      "input_data": "1\n5\n4",
      "expected_output": "0",
      "is_public": false
    },
    {
      "input_data": "1\n4\n5",
      "expected_output": "-1",
      "is_public": false
    },
    {
      "input_data": "4\n5 1 2 3\n4 4 1 5",
      "expected_output": "-1",
      "is_public": false
    },
    {
      "input_data": "6\n1 2 3 4 5 100\n1 2 3 4 5 1",
      "expected_output": "5",
      "is_public": false
    },
    {
      "input_data": "4\n5 8 2 8\n6 5 6 6",
      "expected_output": "3",
      "is_public": false
    }
  ]
},
{
  "id": 1899,
  "title": "Merge Triplets to Form Target Triplet",
  "description": "A **triplet** is an array of three integers. You are given a 2D integer array **triplets**, where `triplets[i] = [ai, bi, ci]`, and an integer array **target** = `[x, y, z]`.\n\nTo help you achieve the target, you can apply the following operation on `triplets` any number of times (possibly zero):\n\n* Choose two indices (0-indexed) `i` and `j` (`i != j`) and update `triplets[j]` to become `[max(ai, aj), max(bi, bj), max(ci, cj)]`.\n* Ignore the index `i` for the rest of the operations.\n\nReturn `true` if it is possible to obtain the **target** triplet `[x, y, z]` as an element of `triplets`, or `false` otherwise.",
  "input_format": "First line: An integer N representing the number of triplets.\nNext N lines: Three space-separated integers representing each triplet.\nLast line: Three space-separated integers representing the target.",
  "output_format": "A single string \"true\" or \"false\".",
  "difficulty": "Medium",
  "tags": [
    "array",
    "greedy"
  ],
  "solution": "### Observations\n1.  If a triplet has any value greater than the corresponding value in `target`, it can NEVER be used. Using it would make the resulting triplet exceed the target (since we only take the `max`). We should ignore such triplets.\n2.  For the remaining valid triplets, we can merge them all together. Merging `[a,b,c]` and `[d,e,f]` results in `[max(a,d), max(b,e), max(c,f)]`.\n3.  If the combined result of all valid triplets equals the target, then it's possible.\n\n### Approach: Greedy\n1.  Initialize a set `res` to store indices we have successfully matched (0, 1, and 2).\n2.  Iterate through each triplet `t`:\n    * If `t[0] > target[0]` or `t[1] > target[1]` or `t[2] > target[2]`: Skip this triplet.\n    * Otherwise, check which components match the target. If `t[i] == target[i]`, add `i` to `res`.\n3.  If `len(res) == 3` (meaning we found valid components for x, y, and z), return `true`.\n\n### Complexity Analysis\n* **Time Complexity:** $O(N)$.\n* **Space Complexity:** $O(1)$.\n\n### Code Logic\n\n**Python Logic**\n```python\ngood = set()\nfor t in triplets:\n    if t[0] > target[0] or t[1] > target[1] or t[2] > target[2]:\n        continue\n    \n    for i, v in enumerate(t):\n        if v == target[i]:\n            good.add(i)\n            \nreturn len(good) == 3\n```",
  "hints": [
    "A triplet with any value larger than the target cannot be part of the solution.",
    "Filter out the 'bad' triplets.",
    "Among the remaining 'good' triplets, check if you can find the target values for each of the 3 positions (x, y, z) at least once.",
    "You don't need to actually simulate the merging. Just checking existence is enough."
  ],
  "boilerplate_python": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n\n    iterator = iter(input_data)\n    try:\n        n = int(next(iterator))\n        triplets = []\n        for _ in range(n):\n            triplets.append([int(next(iterator)), int(next(iterator)), int(next(iterator))])\n        \n        target = [int(next(iterator)), int(next(iterator)), int(next(iterator))]\n    except StopIteration:\n        return\n\n    # Write your code here\n    # result = ...\n\n    # print(\"true\" if result else \"false\")\n\nif __name__ == '__main__':\n    solve()",
  "boilerplate_java": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line = br.readLine();\n        if (line == null) return;\n        int n = Integer.parseInt(line.trim());\n        \n        int[][] triplets = new int[n][3];\n        for(int i=0; i<n; i++) {\n            String[] parts = br.readLine().trim().split(\"\\\\s+\");\n            triplets[i][0] = Integer.parseInt(parts[0]);\n            triplets[i][1] = Integer.parseInt(parts[1]);\n            triplets[i][2] = Integer.parseInt(parts[2]);\n        }\n        \n        String[] tParts = br.readLine().trim().split(\"\\\\s+\");\n        int[] target = new int[]{Integer.parseInt(tParts[0]), Integer.parseInt(tParts[1]), Integer.parseInt(tParts[2])};\n        \n        // Write logic here\n        // boolean result = ...\n        \n        // System.out.println(result ? \"true\" : \"false\");\n    }\n}",
  "test_cases": [
    {
      "input_data": "3\n2 5 3\n1 8 4\n1 7 5\n2 7 5",
      "expected_output": "true",
      "is_public": true
    },
    {
      "input_data": "2\n1 3 4\n1 5 9\n5 5 5",
      "expected_output": "false",
      "is_public": true
    },
    {
      "input_data": "3\n2 5 3\n2 3 4\n1 2 5\n2 5 5",
      "expected_output": "true",
      "is_public": true
    },
    {
      "input_data": "1\n1 2 3\n1 2 3",
      "expected_output": "true",
      "is_public": false
    },
    {
      "input_data": "1\n1 2 10\n1 2 3",
      "expected_output": "false",
      "is_public": false
    },
    {
      "input_data": "4\n1 1 1\n2 2 2\n3 3 3\n10 10 10\n3 3 3",
      "expected_output": "true",
      "is_public": false
    },
    {
      "input_data": "3\n5 1 1\n1 5 1\n1 1 5\n5 5 5",
      "expected_output": "true",
      "is_public": false
    }
  ]
}
]