[
    {
  "id": 215,
  "title": "Kth Largest Element in an Array",
  "description": "Given an integer array **nums** and an integer **k**, return the `k-th` largest element in the array.\n\nNote that it is the `k-th` largest element in the sorted order, not the `k-th` distinct element.\n\nCan you solve it without sorting the entire array?",
  "input_format": "First line: An integer N representing the size of the array.\nSecond line: N space-separated integers representing the array nums.\nThird line: An integer K.",
  "output_format": "A single integer representing the kth largest element.",
  "difficulty": "Medium",
  "tags": [
    "heap",
    "array",
    "sorting"
  ],
  "solution": "### Observations\nA naive approach is to sort the array in descending order and pick the element at index `k-1`. This takes $O(N \\log N)$. However, we only need the $k^{th}$ largest, not the entire sorted array. We can improve this using a **Min-Heap**.\n\n### Approach: Min-Heap\n1.  Maintain a Min-Heap of size `k`.\n2.  Iterate through the array:\n    * Push the current number into the heap.\n    * If the heap size exceeds `k`, pop the smallest element (the root).\n3.  After processing all elements, the heap contains the `k` largest elements of the array.\n4.  The root of this Min-Heap is the smallest among the top `k`, which corresponds precisely to the $k^{th}$ largest element of the entire array.\n\n### Complexity Analysis\n* **Time Complexity:** $O(N \\log k)$. We iterate $N$ times, and heap operations take $O(\\log k)$.\n* **Space Complexity:** $O(k)$ to store the heap.\n\n### Code Logic\n\n**Python Logic**\n```python\nimport heapq\n\nheap = []\nfor num in nums:\n    heapq.heappush(heap, num)\n    if len(heap) > k:\n        heapq.heappop(heap)\nreturn heap[0]\n```",
  "hints": [
    "To find the Kth largest, you don't need to sort the whole array.",
    "Think about maintaining a 'Top K' list as you iterate through the numbers.",
    "A Min-Heap of size K is efficient because the smallest element in the Top K (the root) is exactly the Kth largest element overall.",
    "If the heap grows larger than K, remove the smallest element."
  ],
  "boilerplate_python": "import sys\nimport heapq\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n\n    iterator = iter(input_data)\n    try:\n        n = int(next(iterator))\n        nums = []\n        for _ in range(n):\n            nums.append(int(next(iterator)))\n        k = int(next(iterator))\n    except StopIteration:\n        return\n\n    # Write your code here\n    # result = ...\n\n    # print(result)\n\nif __name__ == '__main__':\n    solve()",
  "boilerplate_java": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line = br.readLine();\n        if (line == null) return;\n        int n = Integer.parseInt(line.trim());\n        \n        int[] nums = new int[n];\n        String[] parts = br.readLine().trim().split(\"\\\\s+\");\n        for(int i=0; i<n; i++) {\n            nums[i] = Integer.parseInt(parts[i]);\n        }\n        \n        int k = Integer.parseInt(br.readLine().trim());\n        \n        // Write logic here\n        // int result = ...\n        \n        // System.out.println(result);\n    }\n}",
  "test_cases": [
    {
      "input_data": "6\n3 2 1 5 6 4\n2",
      "expected_output": "5",
      "is_public": true
    },
    {
      "input_data": "9\n3 2 3 1 2 4 5 5 6\n4",
      "expected_output": "4",
      "is_public": true
    },
    {
      "input_data": "1\n1\n1",
      "expected_output": "1",
      "is_public": false
    },
    {
      "input_data": "5\n-1 -2 -3 -4 -5\n2",
      "expected_output": "-2",
      "is_public": false
    },
    {
      "input_data": "5\n100 100 100 100 100\n3",
      "expected_output": "100",
      "is_public": false
    },
    {
      "input_data": "6\n1 2 3 4 5 1000\n1",
      "expected_output": "1000",
      "is_public": false
    },
    {
      "input_data": "6\n1 2 3 4 5 1000\n6",
      "expected_output": "1",
      "is_public": false
    }
  ]
},
{
  "id": 23,
  "title": "Merge k Sorted Lists",
  "description": "You are given an array of `k` linked-lists **lists**, each linked-list is sorted in ascending order.\n\nMerge all the linked-lists into one sorted linked-list and return it.",
  "input_format": "First line: An integer K representing the number of lists.\nNext K lines: Each line starts with an integer M (size of list), followed by M space-separated integers representing the node values.",
  "output_format": "A single line containing the space-separated integers of the merged list.",
  "difficulty": "Hard",
  "tags": [
    "heap",
    "linked_list"
  ],
  "solution": "### Observations\nWe need to merge $k$ sorted lists. A naive approach would be to collect all values into an array, sort them, and rebuild a list ($O(N \\log N)$ where $N$ is total elements). However, since the individual lists are already sorted, we can use a **Min-Heap** to efficiently select the smallest current element among the $k$ lists.\n\n### Approach: Min-Heap\n1.  Initialize a Min-Heap.\n2.  Push the **head node** of every non-empty list into the heap. The heap should store tuples/objects `(value, list_index, node)` so we know which list the value came from.\n3.  Create a dummy head for the result list.\n4.  While the heap is not empty:\n    * Pop the smallest node from the heap.\n    * Append this node to the result list.\n    * If the popped node has a `next` node, push that `next` node into the heap.\n\n### Complexity Analysis\n* **Time Complexity:** $O(N \\log k)$, where $N$ is the total number of nodes and $k$ is the number of lists. Heap operations take $O(\\log k)$.\n* **Space Complexity:** $O(k)$ for the heap.\n\n### Code Logic\n\n**Python Logic**\n```python\nimport heapq\n\n# Heap stores tuples: (node.val, i, node)\nmin_heap = []\nfor i, l in enumerate(lists):\n    if l:\n        heapq.heappush(min_heap, (l.val, i, l))\n\ndummy = ListNode(0)\ncurr = dummy\n\nwhile min_heap:\n    val, i, node = heapq.heappop(min_heap)\n    curr.next = node\n    curr = curr.next\n    if node.next:\n        heapq.heappush(min_heap, (node.next.val, i, node.next))\n\nreturn dummy.next\n```",
  "hints": [
    "Since all lists are sorted, the smallest element of the entire answer must be one of the heads of the K lists.",
    "If you pick the smallest head, the next smallest element must be either one of the remaining K-1 heads or the next element from the list you just picked from.",
    "Use a Min-Heap to keep track of the current head of every list.",
    "Always pop the smallest value from the heap, add it to your result, and push the next node from that specific list back into the heap."
  ],
  "boilerplate_python": "import sys\nimport heapq\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n\n    iterator = iter(input_data)\n    try:\n        k = int(next(iterator))\n        lists = []\n        for _ in range(k):\n            m = int(next(iterator))\n            if m == 0:\n                lists.append(None)\n                continue\n            head = ListNode(int(next(iterator)))\n            curr = head\n            for _ in range(m-1):\n                curr.next = ListNode(int(next(iterator)))\n                curr = curr.next\n            lists.append(head)\n    except StopIteration:\n        return\n\n    # Write your code here to merge 'lists' (list of ListNode)\n    # result_head = ...\n\n    # Printing logic\n    # curr = result_head\n    # out = []\n    # while curr:\n    #     out.append(str(curr.val))\n    #     curr = curr.next\n    # print(\" \".join(out))\n\nif __name__ == '__main__':\n    solve()",
  "boilerplate_java": "import java.io.*;\nimport java.util.*;\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode(int val) { this.val = val; }\n}\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line = br.readLine();\n        if (line == null) return;\n        int k = Integer.parseInt(line.trim());\n        \n        ListNode[] lists = new ListNode[k];\n        \n        for(int i=0; i<k; i++) {\n            String[] parts = br.readLine().trim().split(\"\\\\s+\");\n            int m = Integer.parseInt(parts[0]);\n            if(m == 0) continue;\n            \n            lists[i] = new ListNode(Integer.parseInt(parts[1]));\n            ListNode curr = lists[i];\n            for(int j=1; j<m; j++) {\n                curr.next = new ListNode(Integer.parseInt(parts[j+1]));\n                curr = curr.next;\n            }\n        }\n        \n        // Write logic here\n        // ListNode result = ...\n        \n        /*\n        ListNode curr = result;\n        StringBuilder sb = new StringBuilder();\n        while(curr != null) {\n            sb.append(curr.val).append(\" \");\n            curr = curr.next;\n        }\n        System.out.println(sb.toString().trim());\n        */\n    }\n}",
  "test_cases": [
    {
      "input_data": "3\n3 1 4 5\n3 1 3 4\n2 2 6",
      "expected_output": "1 1 2 3 4 4 5 6",
      "is_public": true
    },
    {
      "input_data": "1\n0",
      "expected_output": "",
      "is_public": true
    },
    {
      "input_data": "3\n0\n1 1\n0",
      "expected_output": "1",
      "is_public": true
    },
    {
      "input_data": "2\n2 10 20\n2 15 25",
      "expected_output": "10 15 20 25",
      "is_public": false
    },
    {
      "input_data": "4\n1 1\n1 2\n1 3\n1 4",
      "expected_output": "1 2 3 4",
      "is_public": false
    },
    {
      "input_data": "2\n3 5 10 15\n3 0 1 2",
      "expected_output": "0 1 2 5 10 15",
      "is_public": false
    },
    {
      "input_data": "2\n2 -10 -5\n1 -20",
      "expected_output": "-20 -10 -5",
      "is_public": false
    }
  ]
},{
  "id": 347,
  "title": "Top K Frequent Elements",
  "description": "Given an integer array **nums** and an integer **k**, return the `k` most frequent elements. You may return the answer in **any order**.",
  "input_format": "First line: An integer N representing the size of the array.\nSecond line: N space-separated integers representing the array nums.\nThird line: An integer K.",
  "output_format": "A single line containing K space-separated integers.",
  "difficulty": "Medium",
  "tags": [
    "array",
    "map",
    "heap",
    "bucket_sort"
  ],
  "solution": "### Observations\nWe need to count the frequency of each number first, which requires a Hash Map ($O(N)$). Once we have frequencies, we need to extract the top $k$. Sorting all frequencies would take $O(N \\log N)$. Can we do better?\n\n### Approach 1: Min-Heap\n1.  Count frequencies using a Hash Map.\n2.  Use a Min-Heap to store pairs of `(frequency, number)`.\n3.  Iterate through the unique numbers. Push into heap.\n4.  If heap size > `k`, pop the smallest frequency. This keeps the `k` largest frequencies in the heap.\n5.  **Time:** $O(N \\log k)$.\n\n### Approach 2: Bucket Sort (Linear Time)\n1.  Count frequencies.\n2.  Create an array of lists `buckets` where indices represent frequency (0 to N).\n3.  For each number, add it to the bucket corresponding to its frequency.\n4.  Iterate from the back of the `buckets` array (highest frequency) to the front, collecting numbers until we have `k` elements.\n5.  **Time:** $O(N)$.\n\n### Code Logic (Heap)\n\n**Python Logic**\n```python\nimport heapq\nfrom collections import Counter\n\ncount = Counter(nums)\nheap = []\n\nfor num, freq in count.items():\n    heapq.heappush(heap, (freq, num))\n    if len(heap) > k:\n        heapq.heappop(heap)\n\nreturn [num for freq, num in heap]\n```",
  "hints": [
    "First, you need to know how many times each element appears. Use a Hash Map (Dictionary) for this.",
    "Once you have the counts, you essentially have a list of pairs (number, count). You need the top K pairs sorted by count.",
    "A Min-Heap of size K can maintain the top K elements efficiently.",
    "Alternatively, since the maximum frequency cannot exceed the array size N, can you use Bucket Sort?"
  ],
  "boilerplate_python": "import sys\nimport heapq\nfrom collections import Counter\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n\n    iterator = iter(input_data)\n    try:\n        n = int(next(iterator))\n        nums = []\n        for _ in range(n):\n            nums.append(int(next(iterator)))\n        k = int(next(iterator))\n    except StopIteration:\n        return\n\n    # Write your code here\n    # result = ...\n\n    # print(*(result))\n\nif __name__ == '__main__':\n    solve()",
  "boilerplate_java": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line = br.readLine();\n        if (line == null) return;\n        int n = Integer.parseInt(line.trim());\n        \n        int[] nums = new int[n];\n        String[] parts = br.readLine().trim().split(\"\\\\s+\");\n        for(int i=0; i<n; i++) {\n            nums[i] = Integer.parseInt(parts[i]);\n        }\n        \n        int k = Integer.parseInt(br.readLine().trim());\n        \n        // Write logic here\n        // int[] result = ...\n        \n        /*\n        StringBuilder sb = new StringBuilder();\n        for(int i : result) sb.append(i).append(\" \");\n        System.out.println(sb.toString().trim());\n        */\n    }\n}",
  "test_cases": [
    {
      "input_data": "6\n1 1 1 2 2 3\n2",
      "expected_output": "1 2",
      "is_public": true
    },
    {
      "input_data": "1\n1\n1",
      "expected_output": "1",
      "is_public": true
    },
    {
      "input_data": "6\n1 2 3 4 5 6\n6",
      "expected_output": "1 2 3 4 5 6",
      "is_public": false
    },
    {
      "input_data": "4\n10 10 20 20\n2",
      "expected_output": "10 20",
      "is_public": false
    },
    {
      "input_data": "5\n4 4 4 1 1\n1",
      "expected_output": "4",
      "is_public": false
    },
    {
      "input_data": "7\n5 5 5 2 2 8 8\n2",
      "expected_output": "5 2",
      "is_public": false
    },
    {
      "input_data": "2\n-1 -1\n1",
      "expected_output": "-1",
      "is_public": false
    }
  ]
},{
  "id": 253,
  "title": "Meeting Rooms II",
  "description": "Given an array of meeting time intervals **intervals** where `intervals[i] = [start, end]`, return the minimum number of conference rooms required.\n\n### Example\n**Input:** `intervals = [[0,30],[5,10],[15,20]]`\n**Output:** `2`",
  "input_format": "First line: An integer N representing the number of meetings.\nNext N lines: Two space-separated integers start and end.",
  "output_format": "A single integer representing the number of rooms.",
  "difficulty": "Medium",
  "tags": [
    "array",
    "heap",
    "sorting",
    "two_pointers"
  ],
  "solution": "### Observations\nWe need to find the maximum number of overlapping meetings at any point in time. When a meeting starts, we need a room. When a meeting ends, a room becomes free.\n\n### Approach: Min-Heap\n1.  **Sort** the meetings by their **start time**. This helps us process meetings in chronological order.\n2.  Use a **Min-Heap** to track the **end times** of ongoing meetings.\n3.  Iterate through the sorted meetings:\n    * If the earliest ending meeting (heap top) ends *before or at* the current meeting's start time, it means that room is free. We remove that meeting from the heap (pop).\n    * Add the current meeting's end time to the heap (push).\n    * The size of the heap tells us how many rooms are currently occupied.\n4.  The result is the maximum size the heap reached (or simply the heap size at the end, as it never shrinks below the necessary count).\n\n### Complexity Analysis\n* **Time Complexity:** $O(N \\log N)$ for sorting. Heap operations take $O(N \\log N)$.\n* **Space Complexity:** $O(N)$ for the heap.\n\n### Code Logic\n\n**Python Logic**\n```python\nimport heapq\n\nintervals.sort(key=lambda x: x[0])\nheap = []  # Stores end times\n\nfor start, end in intervals:\n    # If the earliest ending meeting is done before this one starts\n    if heap and heap[0] <= start:\n        heapq.heappop(heap)\n    heapq.heappush(heap, end)\n\nreturn len(heap)\n```",
  "hints": [
    "Sort the intervals by start time so you can process them in order.",
    "You need to keep track of end times of meetings currently in progress.",
    "A Min-Heap can efficiently tell you which meeting ends the earliest.",
    "If the earliest meeting ends before the current one starts, you can reuse that room (pop from heap)."
  ],
  "boilerplate_python": "import sys\nimport heapq\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n\n    iterator = iter(input_data)\n    try:\n        n = int(next(iterator))\n        intervals = []\n        for _ in range(n):\n            s = int(next(iterator))\n            e = int(next(iterator))\n            intervals.append([s, e])\n    except StopIteration:\n        return\n\n    # Write your code here\n    # result = ...\n\n    # print(result)\n\nif __name__ == '__main__':\n    solve()",
  "boilerplate_java": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line = br.readLine();\n        if (line == null) return;\n        int n = Integer.parseInt(line.trim());\n        \n        int[][] intervals = new int[n][2];\n        for(int i=0; i<n; i++) {\n            String[] parts = br.readLine().trim().split(\"\\\\s+\");\n            intervals[i][0] = Integer.parseInt(parts[0]);\n            intervals[i][1] = Integer.parseInt(parts[1]);\n        }\n        \n        // Write logic here\n        // int rooms = ...\n        \n        // System.out.println(rooms);\n    }\n}",
  "test_cases": [
    {
      "input_data": "3\n0 30\n5 10\n15 20",
      "expected_output": "2",
      "is_public": true
    },
    {
      "input_data": "2\n7 10\n2 4",
      "expected_output": "1",
      "is_public": true
    },
    {
      "input_data": "1\n1 10",
      "expected_output": "1",
      "is_public": false
    },
    {
      "input_data": "4\n1 5\n4 6\n5 8\n7 9",
      "expected_output": "2",
      "is_public": false
    },
    {
      "input_data": "4\n1 10\n2 3\n4 5\n6 7",
      "expected_output": "2",
      "is_public": false
    },
    {
      "input_data": "3\n1 5\n1 5\n1 5",
      "expected_output": "3",
      "is_public": false
    },
    {
      "input_data": "5\n1 4\n2 5\n3 6\n4 7\n5 8",
      "expected_output": "3",
      "is_public": false
    },
    {
      "input_data": "3\n1 2\n2 3\n3 4",
      "expected_output": "1",
      "is_public": false
    }
  ]
},{
  "id": 407,
  "title": "Trapping Rain Water II",
  "description": "Given an `m x n` integer matrix **heightMap** representing the height of each unit cell in a 2D elevation map, return the volume of water it can trap after raining.\n\n### Constraints\n* `m == heightMap.length`\n* `n == heightMap[i].length`\n* `1 <= m, n <= 200`\n* `0 <= heightMap[i][j] <= 2 * 10^4`",
  "input_format": "First line: Two integers M and N.\nNext M lines: N space-separated integers representing the height map.",
  "output_format": "A single integer representing the total water trapped.",
  "difficulty": "Hard",
  "tags": [
    "heap",
    "bfs",
    "array",
    "matrix"
  ],
  "solution": "### Observations\nWater flows from higher cells to lower cells and spills out from the boundaries. The amount of water a cell can hold is determined by the shortest boundary surrounding it. This is similar to the 1D Trapping Rain Water problem but in 2D.\n\n### Approach: Min-Heap + BFS\n1.  **Boundary:** Add all cells on the border of the matrix to a Min-Heap. These form the initial retaining wall. Mark them as visited.\n2.  **Process:** While the heap is not empty:\n    * Pop the cell with the smallest height `(h, r, c)` from the heap. This represents the lowest point in the current boundary wall.\n    * Check its 4 neighbors.\n    * If a neighbor hasn't been visited:\n        * If the neighbor's height is less than the current boundary height `h`, it will trap water: `water += h - neighbor_height`.\n        * The effective height of the neighbor becomes `max(h, neighbor_height)` (because water fills it up to `h`, or it acts as a new higher wall).\n        * Push the neighbor to the heap with this effective height.\n        * Mark as visited.\n\n### Complexity Analysis\n* **Time Complexity:** $O(M \\times N \\log(M \\times N))$. Each cell is pushed and popped from the heap at most once.\n* **Space Complexity:** $O(M \\times N)$ for the visited array and heap.\n\n### Code Logic\n\n**Python Logic**\n```python\nimport heapq\n\nif not heightMap or not heightMap[0]: return 0\nm, n = len(heightMap), len(heightMap[0])\nheap = []\nvisited = [[False]*n for _ in range(m)]\n\n# Add borders\nfor i in range(m):\n    for j in range(n):\n        if i == 0 or j == 0 or i == m-1 or j == n-1:\n            heapq.heappush(heap, (heightMap[i][j], i, j))\n            visited[i][j] = True\n\nres = 0\ndirs = [(0,1), (0,-1), (1,0), (-1,0)]\n\nwhile heap:\n    h, r, c = heapq.heappop(heap)\n    for dr, dc in dirs:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < m and 0 <= nc < n and not visited[nr][nc]:\n            res += max(0, h - heightMap[nr][nc])\n            heapq.heappush(heap, (max(h, heightMap[nr][nc]), nr, nc))\n            visited[nr][nc] = True\nreturn res\n```",
  "hints": [
    "Think about the boundary of the grid. Water cannot be trapped on the boundary.",
    "The water level is dictated by the lowest wall surrounding a region. This suggests using a Min-Heap to process the lowest boundary first.",
    "Start by adding all boundary cells to the Min-Heap.",
    "When you pick the lowest boundary cell, check its unvisited neighbors. If a neighbor is lower, it traps water. If it's higher, it becomes a new boundary wall."
  ],
  "boilerplate_python": "import sys\nimport heapq\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n\n    iterator = iter(input_data)\n    try:\n        m = int(next(iterator))\n        n = int(next(iterator))\n        height_map = []\n        for _ in range(m):\n            row = []\n            for _ in range(n):\n                row.append(int(next(iterator)))\n            height_map.append(row)\n    except StopIteration:\n        return\n\n    # Write your code here\n    # result = ...\n\n    # print(result)\n\nif __name__ == '__main__':\n    solve()",
  "boilerplate_java": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line = br.readLine();\n        if (line == null) return;\n        \n        String[] dims = line.trim().split(\"\\\\s+\");\n        int m = Integer.parseInt(dims[0]);\n        int n = Integer.parseInt(dims[1]);\n        \n        int[][] heightMap = new int[m][n];\n        for(int i=0; i<m; i++) {\n            String[] parts = br.readLine().trim().split(\"\\\\s+\");\n            for(int j=0; j<n; j++) {\n                heightMap[i][j] = Integer.parseInt(parts[j]);\n            }\n        }\n        \n        // Write logic here\n        // int water = ...\n        \n        // System.out.println(water);\n    }\n}",
  "test_cases": [
    {
      "input_data": "3 6\n1 4 3 1 3 2\n3 2 1 3 2 4\n2 3 3 2 3 1",
      "expected_output": "4",
      "is_public": true
    },
    {
      "input_data": "5 5\n3 3 3 3 3\n3 2 2 2 3\n3 2 1 2 3\n3 2 2 2 3\n3 3 3 3 3",
      "expected_output": "10",
      "is_public": true
    },
    {
      "input_data": "3 3\n1 1 1\n1 1 1\n1 1 1",
      "expected_output": "0",
      "is_public": false
    },
    {
      "input_data": "3 3\n5 5 5\n5 1 5\n5 5 5",
      "expected_output": "4",
      "is_public": false
    },
    {
      "input_data": "1 5\n1 2 3 4 5",
      "expected_output": "0",
      "is_public": false
    },
    {
      "input_data": "4 4\n10 10 10 10\n10 5 4 10\n10 4 5 10\n10 10 10 10",
      "expected_output": "17",
      "is_public": false
    },
    {
      "input_data": "4 4\n5 5 5 5\n5 1 1 5\n5 1 1 5\n5 5 5 5",
      "expected_output": "16",
      "is_public": false
    }
  ]
}
]