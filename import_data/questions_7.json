[
  {
    "id": 208,
    "title": "Implement Trie (Prefix Tree)",
    "description": "A **Trie** (pronounced as \"try\") or **Prefix Tree** is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\n\nImplement the Trie class:\n\n* `insert(word)`: Inserts the string **word** into the trie.\n* `search(word)`: Returns `true` if the string **word** is in the trie (i.e., was inserted before), and `false` otherwise.\n* `startsWith(prefix)`: Returns `true` if there is a previously inserted string **word** that has the prefix **prefix**, and `false` otherwise.",
    "input_format": "The first line contains an integer **Q**, the number of operations.\nThe next **Q** lines each contain a command string and a value string separated by a space. Commands are: `insert`, `search`, `startsWith`.",
    "output_format": "For each `search` or `startsWith` command, print `true` or `false` on a new line.",
    "difficulty": "Medium",
    "tags": [
      "trie",
      "string",
      "tree"
    ],
    "solution": "### Observations\nA Trie is a specialized tree used for searching strings. Unlike a binary search tree, nodes do not store the keys associated with them. Instead, a node's position in the tree defines the key. All descendants of a node have a common prefix of the string associated with that node.\n\n### Approach\n1.  **Node Structure**: Each node contains a dictionary (or array of size 26) to map characters to children nodes and a boolean flag `is_end` to mark if a word concludes at this node.\n2.  **Insert**: Iterate through the characters of the word. For each char, check if it exists in the current node's children. If not, create a new node. Move to the child. After the loop, mark the final node as `is_end = True`.\n3.  **Search**: Similar to insert, traverse the trie based on characters. If a child doesn't exist, return `False`. If the traversal completes, return the value of `is_end` of the current node.\n4.  **StartsWith**: Identical to search, but return `True` as long as the traversal completes (we don't check `is_end`).\n\n### Complexity Analysis\n* **Time Complexity**: $O(L)$ for each operation, where $L$ is the length of the word.\n* **Space Complexity**: $O(N \\times L)$ where $N$ is the number of words inserted and $L$ is the average length.\n\n### Code Logic\n```python\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end\n\n    def startsWith(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True\n```",
    "hints": [
      "Think of the Trie as a tree where each edge represents a character.",
      "You need a class `TrieNode` that holds links to children (like a Map or array of size 26).",
      "Don't forget a boolean flag in `TrieNode` to indicate if a word ends at that specific character.",
      "For `startsWith`, you only need to verify if the path exists; you don't need the boolean end flag."
    ],
    "boilerplate_python": "import sys\n\n# Helper classes if needed\nclass TrieNode:\n    pass\n\ndef solve():\n    # Reading input\n    input = sys.stdin.read().split()\n    if not input: return\n    iterator = iter(input)\n    \n    try:\n        Q = int(next(iterator))\n    except StopIteration:\n        return\n        \n    # Initialize your data structure here\n    \n    for _ in range(Q):\n        command = next(iterator)\n        arg = next(iterator)\n        # Process commands\n\nif __name__ == \"__main__\":\n    solve()",
    "boilerplate_java": "import java.util.*;\nimport java.io.*;\n\nclass Solution {\n    static class Trie {\n        // Implement Trie here\n        public Trie() {}\n        public void insert(String word) {}\n        public boolean search(String word) { return false; }\n        public boolean startsWith(String prefix) { return false; }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (!sc.hasNext()) return;\n        int Q = sc.nextInt();\n        Trie trie = new Trie();\n        \n        for (int i = 0; i < Q; i++) {\n            String command = sc.next();\n            String arg = sc.next();\n            if (command.equals(\"insert\")) {\n                trie.insert(arg);\n            } else if (command.equals(\"search\")) {\n                System.out.println(trie.search(arg) ? \"true\" : \"false\");\n            } else if (command.equals(\"startsWith\")) {\n                System.out.println(trie.startsWith(arg) ? \"true\" : \"false\");\n            }\n        }\n    }\n}",
    "test_cases": [
      {
        "input_data": "6\ninsert apple\nsearch apple\nsearch app\nstartsWith app\ninsert app\nsearch app",
        "expected_output": "true\nfalse\ntrue\ntrue",
        "is_public": true
      },
      {
        "input_data": "3\ninsert dog\nsearch dog\nstartsWith d",
        "expected_output": "true\ntrue",
        "is_public": true
      },
      {
        "input_data": "2\ninsert a\nsearch a",
        "expected_output": "true",
        "is_public": false
      },
      {
        "input_data": "3\ninsert hello\nsearch hell\nstartsWith hell",
        "expected_output": "false\ntrue",
        "is_public": false
      },
      {
        "input_data": "4\ninsert car\ninsert cart\nsearch car\nsearch cart",
        "expected_output": "true\ntrue",
        "is_public": false
      },
      {
        "input_data": "5\ninsert longstring\nstartsWith long\nstartsWith longs\nsearch longstrin\nsearch longstring",
        "expected_output": "true\ntrue\nfalse\ntrue",
        "is_public": false
      }
    ]
  },
  {
    "id": 212,
    "title": "Word Search II",
    "description": "Given an `m x n` board of characters **board** and a list of strings **words**, return *all words on the board*.\n\nEach word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\n\n",
    "input_format": "Line 1: Two integers **M** and **N** (rows and cols).\nNext **M** lines: A string or space-separated characters representing the row.\nNext Line: Integer **K** (number of words).\nNext **K** lines: The dictionary words.",
    "output_format": "Print the found words sorted lexicographically, each on a new line.",
    "difficulty": "Hard",
    "tags": [
      "array",
      "string",
      "backtracking",
      "trie",
      "matrix"
    ],
    "solution": "### Observations\nA naive DFS for each word is too slow because the board is traversed repeatedly. We need to search for *multiple* words simultaneously. A Trie (Prefix Tree) allows us to store all target words and prune the search early if a path on the board doesn't match any prefix in the dictionary.\n\n### Approach\n1.  **Build Trie**: Insert all words from the list into a Trie. Each Trie node should store the word itself (at the leaf) to avoid reconstructing it during recursion.\n2.  **Backtracking (DFS)**: Iterate over every cell $(r, c)$ in the board.\n3.  **Recursive Step**: If the current character exists in the current Trie node's children, move to that child and mark the cell as visited.\n4.  **Found Word**: If the Trie node has a word stored (non-null), add it to the result set. \n5.  **Optimization**: To avoid duplicates, remove the word from the Trie or use a Set for results. Crucially, prune leaf nodes from the Trie after a word is found to avoid re-visiting paths that lead to nowhere.\n\n### Complexity Analysis\n* **Time Complexity**: $O(M \\times N \\times 3^{L})$ where $L$ is the max length of a word (3 directions usually after first step).\n* **Space Complexity**: $O(\\Sigma |w|)$ for the Trie.\n\n### Code Logic\n```python\ndef findWords(board, words):\n    trie = {}\n    for w in words:\n        t = trie\n        for c in w:\n            if c not in t: t[c] = {}\n            t = t[c]\n        t['#'] = w  # Store word at leaf\n\n    res = set()\n    rows, cols = len(board), len(board[0])\n\n    def dfs(r, c, node):\n        char = board[r][c]\n        if char not in node: return\n        \n        curr_node = node[char]\n        if '#' in curr_node:\n            res.add(curr_node['#'])\n            # Optimization: could remove '#' here\n        \n        board[r][c] = '*' # mark visited\n        for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:\n            nr, nc = r+dr, c+dc\n            if 0 <= nr < rows and 0 <= nc < cols and board[nr][nc] != '*':\n                dfs(nr, nc, curr_node)\n        board[r][c] = char # backtrack\n\n    for r in range(rows):\n        for c in range(cols):\n            dfs(r, c, trie)\n    return sorted(list(res))\n```",
    "hints": [
      "Instead of running DFS for every word, run DFS on the board once and check against all words simultaneously.",
      "Use a Trie to store the list of words.",
      "During DFS, if the current path isn't a prefix of any word in the Trie, stop immediately (pruning).",
      "Store the full word at the end node of the Trie to easily add it to the result list.",
      "Don't forget to backtrack: restore the board cell's value after visiting."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data: return\n    iterator = iter(input_data)\n    \n    try:\n        M = int(next(iterator))\n        N = int(next(iterator))\n        board = []\n        for _ in range(M):\n            # Handling potentially space-separated chars or strings\n            row_str = next(iterator)\n            if len(row_str) == 1 and N > 1:\n                # Likely space separated, collect rest\n                row = [row_str]\n                for _ in range(N-1): row.append(next(iterator))\n                board.append(row)\n            else:\n                board.append(list(row_str))\n                \n        K = int(next(iterator))\n        words = []\n        for _ in range(K):\n            words.append(next(iterator))\n            \n        # Call logic\n        # result = findWords(board, words)\n        # for word in sorted(result):\n        #     print(word)\n        pass\n    except StopIteration:\n        return\n\nif __name__ == \"__main__\":\n    solve()",
    "boilerplate_java": "import java.util.*;\nimport java.io.*;\n\nclass Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (!sc.hasNextInt()) return;\n        int M = sc.nextInt();\n        int N = sc.nextInt();\n        char[][] board = new char[M][N];\n        for (int i = 0; i < M; i++) {\n            // Depending on input format, might be a string or chars\n            // Assuming string for simplicity based on typical CP input\n            String row = sc.next();\n            if (row.length() < N) {\n                 // if space separated\n                 board[i][0] = row.charAt(0);\n                 for(int j=1; j<N; j++) board[i][j] = sc.next().charAt(0);\n            } else {\n                 board[i] = row.toCharArray();\n            }\n        }\n        \n        int K = sc.nextInt();\n        String[] words = new String[K];\n        for (int i = 0; i < K; i++) words[i] = sc.next();\n        \n        // logic here\n        // output sorted words\n    }\n}",
    "test_cases": [
      {
        "input_data": "4 4\noaan\netae\nihkr\niflv\n4\noath\npea\neat\nrain",
        "expected_output": "eat\noath",
        "is_public": true
      },
      {
        "input_data": "2 2\nab\ncd\n1\nabcd",
        "expected_output": "",
        "is_public": true
      },
      {
        "input_data": "1 1\na\n1\na",
        "expected_output": "a",
        "is_public": false
      },
      {
        "input_data": "3 3\nabc\ndef\nghi\n3\nabc\ncfi\ndad",
        "expected_output": "abc\ncfi",
        "is_public": false
      },
      {
        "input_data": "2 2\naa\naa\n1\naaaa",
        "expected_output": "",
        "is_public": false
      },
      {
        "input_data": "2 2\naa\naa\n1\naaa",
        "expected_output": "aaa",
        "is_public": false
      },
      {
        "input_data": "3 3\nabc\naed\nafg\n1\nabcdefg",
        "expected_output": "abcdefg",
        "is_public": false
      }
    ]
  },
  {
    "id": 211,
    "title": "Design Add and Search Words Data Structure",
    "description": "Design a data structure that supports adding new words and finding if a string matches any previously added string.\n\nImplement the data structure class:\n\n* `addWord(word)`: Adds **word** to the data structure.\n* `search(word)`: Returns `true` if there is any string in the data structure that matches **word**, or `false` otherwise. **word** may contain dots `.` where dots can be matched with any letter.",
    "input_format": "Line 1: Integer **Q** (number of operations).\nNext **Q** lines: Command `addWord` or `search` followed by the string.",
    "output_format": "For each `search` command, print `true` or `false` on a new line.",
    "difficulty": "Medium",
    "tags": [
      "trie",
      "string",
      "searching",
      "design"
    ],
    "solution": "### Observations\nStandard search is identical to a standard Trie. However, the wildcard `.` handling requires us to explore *all* possible children of the current node when we encounter it.\n\n### Approach\n1.  **Trie Construction**: Standard Insert.\n2.  **Search with DFS**: Create a recursive helper `dfs(index, node)`.\n    * **Base Case**: If `index == len(word)`, return `node.is_end`.\n    * **Wildcard Case**: If `word[index] == '.'`, iterate through all keys/children of the current node. If `dfs(index + 1, child)` returns `True` for any child, return `True`.\n    * **Standard Case**: If `word[index]` is a letter, check if it exists in children. If no, return `False`. If yes, recurse `dfs(index + 1, node.children[char])`.\n\n### Complexity Analysis\n* **Time Complexity**: `addWord` is $O(L)$. `search` is $O(L)$ for words without dots, but can be $O(26^L)$ in the worst case (all dots), though effectively pruned in practice.\n* **Space Complexity**: $O(\\Sigma L)$ to store the trie.\n\n### Code Logic\n```python\nclass WordDictionary:\n    def __init__(self):\n        self.trie = {}\n\n    def addWord(self, word):\n        node = self.trie\n        for c in word:\n            if c not in node: node[c] = {}\n            node = node[c]\n        node['$'] = True\n\n    def search(self, word):\n        def dfs(node, i):\n            if i == len(word):\n                return '$' in node\n            \n            if word[i] == '.':\n                for char in node:\n                    if char != '$' and dfs(node[char], i + 1):\n                        return True\n                return False\n            else:\n                if word[i] not in node:\n                    return False\n                return dfs(node[word[i]], i + 1)\n        \n        return dfs(self.trie, 0)\n```",
    "hints": [
      "This is a classic Trie application.",
      "For the '.' character, you cannot go down just one path.",
      "Use recursion (DFS) to check all possible children when you encounter a '.'."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    input = sys.stdin.read().split()\n    if not input: return\n    iterator = iter(input)\n    \n    try:\n        Q = int(next(iterator))\n    except StopIteration:\n        return\n\n    # Initialize WordDictionary logic here\n    \n    for _ in range(Q):\n        cmd = next(iterator)\n        arg = next(iterator)\n        # Process commands\n\nif __name__ == \"__main__\":\n    solve()",
    "boilerplate_java": "import java.util.*;\nimport java.io.*;\n\nclass Solution {\n    // Inner class for Trie\n    static class WordDictionary {\n        public WordDictionary() {}\n        public void addWord(String word) {}\n        public boolean search(String word) { return false; }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (!sc.hasNext()) return;\n        int Q = sc.nextInt();\n        WordDictionary wd = new WordDictionary();\n        \n        for(int i=0; i<Q; i++) {\n            String cmd = sc.next();\n            String arg = sc.next();\n            if(cmd.equals(\"addWord\")) {\n                wd.addWord(arg);\n            } else {\n                System.out.println(wd.search(arg) ? \"true\" : \"false\");\n            }\n        }\n    }\n}",
    "test_cases": [
      {
        "input_data": "4\naddWord bad\naddWord dad\naddWord mad\nsearch pad",
        "expected_output": "false",
        "is_public": true
      },
      {
        "input_data": "4\naddWord bad\naddWord dad\naddWord mad\nsearch bad",
        "expected_output": "true",
        "is_public": true
      },
      {
        "input_data": "3\naddWord bad\naddWord dad\nsearch .ad",
        "expected_output": "true",
        "is_public": true
      },
      {
        "input_data": "3\naddWord bad\naddWord dad\nsearch b..",
        "expected_output": "true",
        "is_public": true
      },
      {
        "input_data": "2\naddWord a\nsearch .",
        "expected_output": "true",
        "is_public": false
      },
      {
        "input_data": "2\naddWord a\nsearch ..",
        "expected_output": "false",
        "is_public": false
      },
      {
        "input_data": "5\naddWord apple\nsearch .....\nsearch appl.\nsearch .pple\nsearch app.e",
        "expected_output": "true\ntrue\ntrue\ntrue",
        "is_public": false
      }
    ]
  },
  {
    "id": 139,
    "title": "Word Break",
    "description": "Given a string **s** and a dictionary of strings **wordDict**, return `true` if **s** can be segmented into a space-separated sequence of one or more dictionary words.\n\nNote that the same word in the dictionary may be reused multiple times in the segmentation.",
    "input_format": "Line 1: String **s**.\nLine 2: Integer **N** (size of wordDict).\nLine 3: **N** space-separated strings (the dictionary).",
    "output_format": "Print `true` if segmentation is possible, otherwise `false`.",
    "difficulty": "Medium",
    "tags": [
      "dp",
      "trie",
      "string",
      "searching"
    ],
    "solution": "### Observations\nWe need to determine if the entire string can be built by concatenating words from the dictionary. This suggests checking valid prefixes: if prefix `s[0:i]` is a valid word, we then recursively check if `s[i:]` can be segmented. This is a classic overlapping subproblems structure suitable for Dynamic Programming.\n\n### Approach\n1.  **DP State**: Let `dp[i]` be true if `s[0:i]` can be segmented.\n2.  **Initialization**: `dp[0] = True` (base case: empty string is valid).\n3.  **Transitions**: For each index `i` from 1 to `len(s)`:\n    * Check every `j` < `i`.\n    * If `dp[j]` is True AND `s[j:i]` is in `wordDict`, then `dp[i] = True`.\n    * Break inner loop early if `dp[i]` becomes True.\n4.  **Optimization**: Instead of checking all `j`, we can iterate through the words in the dictionary. For each valid `dp[j]`, try adding every `word` in dictionary to see if it matches `s[j : j+len(word)]`.\n\n### Complexity Analysis\n* **Time Complexity**: $O(L^2 \\cdot K)$ or $O(L^3)$ depending on implementation, where $L$ is length of string `s`.\n* **Space Complexity**: $O(L)$ for the DP array.\n\n### Code Logic\n```python\ndef wordBreak(s, wordDict):\n    word_set = set(wordDict)\n    dp = [False] * (len(s) + 1)\n    dp[0] = True\n\n    for i in range(1, len(s) + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in word_set:\n                dp[i] = True\n                break\n    return dp[len(s)]\n```",
    "hints": [
      "Try to break the problem into subproblems: can a prefix of the string be segmented?",
      "Use a boolean array `dp` where `dp[i]` indicates if substring `s[0...i-1]` is valid.",
      "The recurrence relation: `dp[i]` is true if there exists `j < i` such that `dp[j]` is true and substring `s[j...i]` is in the dictionary."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data: return\n    iterator = iter(input_data)\n    \n    try:\n        s = next(iterator)\n        n = int(next(iterator))\n        wordDict = []\n        for _ in range(n):\n            wordDict.append(next(iterator))\n            \n        # Call logic\n        # print(\"true\" if wordBreak(s, wordDict) else \"false\")\n    except StopIteration:\n        return\n\nif __name__ == \"__main__\":\n    solve()",
    "boilerplate_java": "import java.util.*;\nimport java.io.*;\n\nclass Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (!sc.hasNext()) return;\n        String s = sc.next();\n        int n = sc.nextInt();\n        List<String> wordDict = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            wordDict.add(sc.next());\n        }\n        \n        // Logic here\n        // System.out.println(result ? \"true\" : \"false\");\n    }\n}",
    "test_cases": [
      {
        "input_data": "leetcode\n2\nleet code",
        "expected_output": "true",
        "is_public": true
      },
      {
        "input_data": "applepenapple\n2\napple pen",
        "expected_output": "true",
        "is_public": true
      },
      {
        "input_data": "catsandog\n5\ncats dog sand and cat",
        "expected_output": "false",
        "is_public": true
      },
      {
        "input_data": "aaaaaaa\n2\naaaa aaa",
        "expected_output": "true",
        "is_public": false
      },
      {
        "input_data": "abc\n3\na b d",
        "expected_output": "false",
        "is_public": false
      },
      {
        "input_data": "goalspecial\n2\ngo goal",
        "expected_output": "false",
        "is_public": false
      },
      {
        "input_data": "a\n1\nb",
        "expected_output": "false",
        "is_public": false
      }
    ]
  }
]