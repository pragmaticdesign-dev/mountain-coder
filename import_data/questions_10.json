[
  {
    "id": 322,
    "title": "Coin Change",
    "description": "You are given an integer array **coins** representing coins of different denominations and an integer **amount** representing a total amount of money.\n\nReturn the *fewest number of coins* that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return `-1`.\n\nYou may assume that you have an infinite number of each kind of coin.",
    "input_format": "First line: An integer 'amount'.\nSecond line: An integer 'n' (size of coins array).\nThird line: 'n' space-separated integers representing the coins.",
    "output_format": "Print a single integer representing the minimum number of coins, or -1 if impossible.",
    "difficulty": "Medium",
    "tags": [
      "dp",
      "array"
    ],
    "solution": "### Observations\nThis is a classic unbounded knapsack problem. We want to minimize the number of items (coins) to reach a target weight (amount). Since we want the minimum count, a greedy approach might fail (e.g., coins [1, 3, 4], amount 6 -> greedy takes 4+1+1 (3 coins), optimal is 3+3 (2 coins)).\n\n### Approach\n1.  **Define State:** Let `dp[i]` be the minimum coins needed to make amount `i`.\n2.  **Base Case:** `dp[0] = 0` (0 coins needed for 0 amount).\n3.  **Transition:** For every amount `i` from 1 to `amount`, iterate through all `c` in `coins`. If `i >= c`, then `dp[i] = min(dp[i], dp[i - c] + 1)`.\n4.  **Initialization:** Initialize `dp` array with `amount + 1` (infinity).\n\n### Complexity Analysis\n- **Time:** O(S * n), where S is the amount and n is the number of coin denominations.\n- **Space:** O(S) for the DP table.\n\n### Code Logic\n```python\ndef solve(coins, amount):\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for i in range(1, amount + 1):\n        for c in coins:\n            if i - c >= 0:\n                dp[i] = min(dp[i], dp[i - c] + 1)\n                \n    return dp[amount] if dp[amount] != float('inf') else -1\n```",
    "hints": [
      "Try to solve sub-problems: what is the minimum coins for amount 1, amount 2...?",
      "If you know the answer for amount `x - coin_value`, can you find the answer for `x`?",
      "Initialize your DP array with a value larger than the maximum possible coins (amount + 1).",
      "Don't forget the base case: 0 coins are needed for amount 0."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    try:\n        input_data = sys.stdin.read().split()\n        if not input_data: return\n        \n        amount = int(input_data[0])\n        n = int(input_data[1])\n        coins = []\n        for i in range(n):\n            coins.append(int(input_data[2 + i]))\n            \n        # Write your logic here\n        dp = [amount + 1] * (amount + 1)\n        dp[0] = 0\n        \n        for i in range(1, amount + 1):\n            for c in coins:\n                if i - c >= 0:\n                    dp[i] = min(dp[i], dp[i - c] + 1)\n                    \n        result = dp[amount] if dp[amount] <= amount else -1\n        print(result)\n        \n    except Exception:\n        return\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (!sc.hasNext()) return;\n        \n        int amount = sc.nextInt();\n        int n = sc.nextInt();\n        int[] coins = new int[n];\n        for (int i = 0; i < n; i++) {\n            coins[i] = sc.nextInt();\n        }\n        \n        // Write Logic Here\n        int[] dp = new int[amount + 1];\n        Arrays.fill(dp, amount + 1);\n        dp[0] = 0;\n        \n        for (int i = 1; i <= amount; i++) {\n            for (int c : coins) {\n                if (i >= c) {\n                    dp[i] = Math.min(dp[i], dp[i - c] + 1);\n                }\n            }\n        }\n        \n        System.out.println(dp[amount] > amount ? -1 : dp[amount]);\n    }\n}",
    "test_cases": [
      {
        "input_data": "11\n3\n1 2 5",
        "expected_output": "3",
        "is_public": true
      },
      {
        "input_data": "3\n1\n2",
        "expected_output": "-1",
        "is_public": true
      },
      {
        "input_data": "0\n1\n1",
        "expected_output": "0",
        "is_public": false
      },
      {
        "input_data": "100\n3\n1 2 5",
        "expected_output": "20",
        "is_public": false
      },
      {
        "input_data": "6\n3\n1 3 4",
        "expected_output": "2",
        "is_public": false
      },
      {
        "input_data": "6249\n3\n186 419 83",
        "expected_output": "20",
        "is_public": false
      }
    ]
  },
  {
    "id": 300,
    "title": "Longest Increasing Subsequence",
    "description": "Given an integer array **nums**, return the length of the longest strictly increasing subsequence.\n\nA subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements.",
    "input_format": "First line: Integer 'N' (size of array).\nSecond line: 'N' space-separated integers.",
    "output_format": "Print a single integer representing the length of the longest increasing subsequence.",
    "difficulty": "Medium",
    "tags": [
      "dp",
      "binary_search",
      "array"
    ],
    "solution": "### Observations\nA naive DP solution takes O(N^2), but we can optimize this by maintaining the \"tails\" of increasing subsequences found so far.\n\n### Approach (Patience Sorting / Binary Search)\n1.  Maintain an array `tails`. `tails[i]` stores the *smallest tail of all increasing subsequences of length i+1* found so far.\n2.  For each number `x` in `nums`:\n    -   If `x` is larger than all tails, append it.\n    -   If `x` can extend an existing subsequence but with a smaller tail value, update the existing tail using Binary Search (specifically `bisect_left`).\n3.  The length of `tails` is the answer.\n\n### Complexity Analysis\n- **Time:** O(N log N) because of binary search inside the loop.\n- **Space:** O(N) to store the tails array.\n\n### Code Logic\n```python\nfrom bisect import bisect_left\ndef lengthOfLIS(nums):\n    tails = []\n    for x in nums:\n        if not tails or x > tails[-1]:\n            tails.append(x)\n        else:\n            idx = bisect_left(tails, x)\n            tails[idx] = x\n    return len(tails)\n```",
    "hints": [
      "Consider the O(N^2) DP approach: dp[i] = max(dp[j]) + 1 for all j < i where nums[j] < nums[i].",
      "Can we speed up finding the previous element using Binary Search?",
      "Think about maintaining a list of 'potential' candidates that start an increasing subsequence.",
      "If you have a subsequence ending in 5, and you find a 3, replacing 5 with 3 allows for more potential future numbers."
    ],
    "boilerplate_python": "import sys\nfrom bisect import bisect_left\n\ndef solve():\n    try:\n        input_data = sys.stdin.read().split()\n        if not input_data: return\n        \n        n = int(input_data[0])\n        nums = [int(x) for x in input_data[1:n+1]]\n        \n        tails = []\n        for x in nums:\n            if not tails or x > tails[-1]:\n                tails.append(x)\n            else:\n                idx = bisect_left(tails, x)\n                tails[idx] = x\n                \n        print(len(tails))\n    except Exception:\n        return\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (!sc.hasNext()) return;\n        \n        int n = sc.nextInt();\n        int[] nums = new int[n];\n        for(int i=0; i<n; i++) nums[i] = sc.nextInt();\n        \n        ArrayList<Integer> tails = new ArrayList<>();\n        for (int num : nums) {\n            int idx = Collections.binarySearch(tails, num);\n            if (idx < 0) idx = -(idx + 1);\n            \n            if (idx == tails.size()) {\n                tails.add(num);\n            } else {\n                tails.set(idx, num);\n            }\n        }\n        \n        System.out.println(tails.size());\n    }\n}",
    "test_cases": [
      {
        "input_data": "6\n10 9 2 5 3 7 101 18",
        "expected_output": "4",
        "is_public": true
      },
      {
        "input_data": "6\n0 1 0 3 2 3",
        "expected_output": "4",
        "is_public": true
      },
      {
        "input_data": "1\n7",
        "expected_output": "1",
        "is_public": false
      },
      {
        "input_data": "5\n7 7 7 7 7",
        "expected_output": "1",
        "is_public": false
      },
      {
        "input_data": "4\n4 3 2 1",
        "expected_output": "1",
        "is_public": false
      },
      {
        "input_data": "8\n10 20 1 2 3 4 5 6",
        "expected_output": "6",
        "is_public": false
      }
    ]
  },
  {
    "id": 152,
    "title": "Maximum Product Subarray",
    "description": "Given an integer array **nums**, find a contiguous non-empty subarray within the array that has the largest product, and return the product.\n\nThe test cases are generated so that the answer will fit in a 32-bit integer.",
    "input_format": "First line: Integer 'N'.\nSecond line: 'N' space-separated integers.",
    "output_format": "Print the maximum product.",
    "difficulty": "Medium",
    "tags": [
      "array",
      "dp"
    ],
    "solution": "### Observations\nUnlike sum, a product can flip from negative to positive if multiplied by a negative number. This means a very small (negative) current product could become the maximum product in the next step.\n\n### Approach\n1.  Maintain both `max_so_far` and `min_so_far` because a negative number multiplied by `min_so_far` (which could be a large negative) becomes a large positive.\n2.  Iterate through the array. If the current number is negative, swap `max_so_far` and `min_so_far`.\n3.  Update `max_so_far` = `max(current, max_so_far * current)`.\n4.  Update `min_so_far` = `min(current, min_so_far * current)`.\n5.  Keep track of the global maximum.\n\n### Complexity Analysis\n- **Time:** O(N) single pass.\n- **Space:** O(1) variables only.\n\n### Code Logic\n```python\ndef maxProduct(nums):\n    res = max(nums)\n    curMin, curMax = 1, 1\n    for n in nums:\n        if n == 0:\n            curMin, curMax = 1, 1\n            continue\n        tmp = curMax * n\n        curMax = max(n * curMax, n * curMin, n)\n        curMin = min(tmp, n * curMin, n)\n        res = max(res, curMax)\n    return res\n```",
    "hints": [
      "This is similar to Kadane's algorithm for Maximum Sum Subarray.",
      "The problem is the negative numbers. A negative times a negative is positive.",
      "Track both the maximum AND the minimum product ending at the current position.",
      "Handle zeros carefully; they reset the subarray product chain."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    try:\n        input_data = sys.stdin.read().split()\n        if not input_data: return\n        \n        n = int(input_data[0])\n        nums = [int(x) for x in input_data[1:n+1]]\n        \n        # Logic\n        res = nums[0]\n        curMax, curMin = 1, 1\n        \n        for x in nums:\n            vals = (x, x * curMax, x * curMin)\n            curMax = max(vals)\n            curMin = min(vals)\n            res = max(res, curMax)\n            \n        print(res)\n    except Exception:\n        return\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (!sc.hasNext()) return;\n        \n        int n = sc.nextInt();\n        int[] nums = new int[n];\n        for(int i=0; i<n; i++) nums[i] = sc.nextInt();\n        \n        long res = nums[0];\n        long curMax = 1, curMin = 1;\n        \n        for (int x : nums) {\n            long tempMax = curMax;\n            curMax = Math.max(x, Math.max(x * curMax, x * curMin));\n            curMin = Math.min(x, Math.min(x * tempMax, x * curMin));\n            res = Math.max(res, curMax);\n        }\n        \n        System.out.println(res);\n    }\n}",
    "test_cases": [
      {
        "input_data": "4\n2 3 -2 4",
        "expected_output": "6",
        "is_public": true
      },
      {
        "input_data": "3\n-2 0 -1",
        "expected_output": "0",
        "is_public": true
      },
      {
        "input_data": "1\n-5",
        "expected_output": "-5",
        "is_public": false
      },
      {
        "input_data": "5\n-2 -3 -4 -5 -6",
        "expected_output": "720",
        "is_public": false
      },
      {
        "input_data": "4\n-2 3 -4 0",
        "expected_output": "24",
        "is_public": false
      },
      {
        "input_data": "6\n2 -5 -2 -4 3 0",
        "expected_output": "24",
        "is_public": false
      }
    ]
  },
  {
    "id": 72,
    "title": "Edit Distance",
    "description": "Given two strings **word1** and **word2**, return the minimum number of operations required to convert **word1** to **word2**.\n\nYou have the following three operations permitted on a word:\n1. Insert a character\n2. Delete a character\n3. Replace a character",
    "input_format": "First line: String 'word1'.\nSecond line: String 'word2'.",
    "output_format": "Print the minimum integer operations.",
    "difficulty": "Hard",
    "tags": [
      "string",
      "dp"
    ],
    "solution": "### Observations\nWe are comparing two strings and need optimal steps. This suggests 2D Dynamic Programming.\n\n### Approach\n1.  **State:** `dp[i][j]` = min operations to convert `word1[0...i-1]` to `word2[0...j-1]`.\n2.  **Base Case:** \n    -   If `word1` is empty, insert all chars of `word2` (`dp[0][j] = j`).\n    -   If `word2` is empty, delete all chars of `word1` (`dp[i][0] = i`).\n3.  **Transition:**\n    -   If `word1[i-1] == word2[j-1]`: No op needed -> `dp[i][j] = dp[i-1][j-1]`.\n    -   Else take min of: `dp[i-1][j]` (Delete), `dp[i][j-1]` (Insert), `dp[i-1][j-1]` (Replace) + 1.\n\n### Complexity Analysis\n- **Time:** O(N * M)\n- **Space:** O(N * M)\n\n### Code Logic\n```python\ndef minDistance(word1, word2):\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n        \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i-1] == word2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n    return dp[m][n]\n```",
    "hints": [
      "Create a 2D table where rows represent prefixes of word1 and columns prefixes of word2.",
      "Consider the last character of both words. If they are equal, we don't need to do anything.",
      "If they are different, we can insert, delete, or replace. Which corresponds to moving left, up, or diagonal in the DP table?",
      "Base cases: transforming an empty string to a string of length L requires L insertions."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    try:\n        input_data = sys.stdin.read().split()\n        if len(input_data) < 2: \n             # Handle empty string cases if input parsing fails usually means empty strings\n             word1 = \"\" if len(input_data) == 0 else input_data[0]\n             word2 = \"\"\n        else:\n             word1 = input_data[0]\n             word2 = input_data[1]\n             \n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m + 1): dp[i][0] = i\n        for j in range(n + 1): dp[0][j] = j\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n                    \n        print(dp[m][n])\n    except Exception:\n        return\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String word1 = sc.hasNext() ? sc.next() : \"\";\n        String word2 = sc.hasNext() ? sc.next() : \"\";\n        \n        int m = word1.length();\n        int n = word2.length();\n        int[][] dp = new int[m + 1][n + 1];\n        \n        for (int i = 0; i <= m; i++) dp[i][0] = i;\n        for (int j = 0; j <= n; j++) dp[0][j] = j;\n        \n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = 1 + Math.min(dp[i - 1][j - 1], \n                                   Math.min(dp[i - 1][j], dp[i][j - 1]));\n                }\n            }\n        }\n        System.out.println(dp[m][n]);\n    }\n}",
    "test_cases": [
      {
        "input_data": "horse\nros",
        "expected_output": "3",
        "is_public": true
      },
      {
        "input_data": "intention\nexecution",
        "expected_output": "5",
        "is_public": true
      },
      {
        "input_data": "a\na",
        "expected_output": "0",
        "is_public": false
      },
      {
        "input_data": "abc\n\n",
        "expected_output": "3",
        "is_public": false
      },
      {
        "input_data": "plasma\naltruism",
        "expected_output": "6",
        "is_public": false
      },
      {
        "input_data": "food\nmoney",
        "expected_output": "4",
        "is_public": false
      }
    ]
  },
  {
    "id": 416,
    "title": "Partition Equal Subset Sum",
    "description": "Given an integer array **nums**, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise.",
    "input_format": "First line: Integer 'N'.\nSecond line: 'N' space-separated integers.",
    "output_format": "Print 'true' or 'false'.",
    "difficulty": "Medium",
    "tags": [
      "dp",
      "array"
    ],
    "solution": "### Observations\nIf the total sum is odd, we cannot split it into two equal integers. If even, we need to find if there exists a subset with sum = `total_sum / 2`.\n\n### Approach (0/1 Knapsack)\n1.  Calculate `total_sum`. If `total_sum % 2 != 0`, return False.\n2.  Target = `total_sum // 2`.\n3.  Use a set or DP array to track all reachable sums.\n4.  Iterate through `nums`. For each num, update the set of reachable sums: `new_sums = {s + num for s in reachable_sums}`.\n\n### Complexity Analysis\n- **Time:** O(N * Target)\n- **Space:** O(Target)\n\n### Code Logic\n```python\ndef canPartition(nums):\n    total = sum(nums)\n    if total % 2 != 0:\n        return False\n    target = total // 2\n    dp = {0}\n    for n in nums:\n        dp.update({v + n for v in dp})\n        if target in dp: return True\n    return False\n```",
    "hints": [
      "Calculate the sum of the array. If it's odd, can we partition it?",
      "This is a variation of the 0/1 Knapsack problem.",
      "We are looking for a subset that sums up to `total_sum / 2`.",
      "You can use a boolean DP array where `dp[i]` is true if sum `i` can be formed."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    try:\n        input_data = sys.stdin.read().split()\n        if not input_data: return\n        \n        n = int(input_data[0])\n        nums = [int(x) for x in input_data[1:n+1]]\n        \n        total = sum(nums)\n        if total % 2 != 0:\n            print(\"false\")\n            return\n            \n        target = total // 2\n        dp = {0}\n        possible = False\n        \n        for num in nums:\n            next_dp = set()\n            for t in dp:\n                if t + num == target:\n                    possible = True\n                    break\n                if t + num < target:\n                    next_dp.add(t + num)\n            if possible: break\n            dp.update(next_dp)\n            \n        print(\"true\" if possible else \"false\")\n    except Exception:\n        return\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (!sc.hasNext()) return;\n        \n        int n = sc.nextInt();\n        int[] nums = new int[n];\n        int total = 0;\n        for(int i=0; i<n; i++) {\n            nums[i] = sc.nextInt();\n            total += nums[i];\n        }\n        \n        if (total % 2 != 0) {\n            System.out.println(\"false\");\n            return;\n        }\n        \n        int target = total / 2;\n        boolean[] dp = new boolean[target + 1];\n        dp[0] = true;\n        \n        for (int num : nums) {\n            for (int i = target; i >= num; i--) {\n                dp[i] = dp[i] || dp[i - num];\n            }\n        }\n        \n        System.out.println(dp[target] ? \"true\" : \"false\");\n    }\n}",
    "test_cases": [
      {
        "input_data": "4\n1 5 11 5",
        "expected_output": "true",
        "is_public": true
      },
      {
        "input_data": "4\n1 2 3 5",
        "expected_output": "false",
        "is_public": true
      },
      {
        "input_data": "2\n1 1",
        "expected_output": "true",
        "is_public": false
      },
      {
        "input_data": "3\n10 20 30",
        "expected_output": "true",
        "is_public": false
      },
      {
        "input_data": "5\n1 2 5 9 100",
        "expected_output": "false",
        "is_public": false
      },
      {
        "input_data": "6\n1 1 1 1 1 1",
        "expected_output": "true",
        "is_public": false
      }
    ]
  },
  {
    "id": 1143,
    "title": "Longest Common Subsequence",
    "description": "Given two strings **text1** and **text2**, return the length of their longest common subsequence. If there is no common subsequence, return 0.\n\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.",
    "input_format": "First line: String 'text1'.\nSecond line: String 'text2'.",
    "output_format": "Print the integer length.",
    "difficulty": "Medium",
    "tags": [
      "string",
      "dp"
    ],
    "solution": "### Observations\nStandard 2D DP problem. We want to maximize the length of matches.\n\n### Approach\n1.  `dp[i][j]` = LCS of `text1[0..i]` and `text2[0..j]`.\n2.  If `text1[i] == text2[j]`, then `dp[i][j] = 1 + dp[i-1][j-1]`.\n3.  Else, `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`.\n\n### Complexity Analysis\n- **Time:** O(N * M)\n- **Space:** O(N * M)\n\n### Code Logic\n```python\ndef longestCommonSubsequence(text1, text2):\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[m][n]\n```",
    "hints": [
      "Use a 2D grid where `grid[i][j]` represents the LCS of the first `i` chars of string 1 and first `j` chars of string 2.",
      "If characters match, the answer is 1 + the answer without those characters.",
      "If characters don't match, we carry forward the best result from excluding one character from either string."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    try:\n        input_data = sys.stdin.read().split()\n        if len(input_data) < 2:\n             text1 = \"\" if len(input_data) == 0 else input_data[0]\n             text2 = \"\"\n        else:\n             text1 = input_data[0]\n             text2 = input_data[1]\n             \n        m, n = len(text1), len(text2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if text1[i - 1] == text2[j - 1]:\n                    dp[i][j] = 1 + dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n                    \n        print(dp[m][n])\n    except Exception:\n        return\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String t1 = sc.hasNext() ? sc.next() : \"\";\n        String t2 = sc.hasNext() ? sc.next() : \"\";\n        \n        int m = t1.length();\n        int n = t2.length();\n        int[][] dp = new int[m + 1][n + 1];\n        \n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (t1.charAt(i - 1) == t2.charAt(j - 1)) {\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        System.out.println(dp[m][n]);\n    }\n}",
    "test_cases": [
      {
        "input_data": "abcde\nace",
        "expected_output": "3",
        "is_public": true
      },
      {
        "input_data": "abc\nabc",
        "expected_output": "3",
        "is_public": true
      },
      {
        "input_data": "abc\ndef",
        "expected_output": "0",
        "is_public": true
      },
      {
        "input_data": "ezupkr\nubmrapg",
        "expected_output": "2",
        "is_public": false
      },
      {
        "input_data": "ylqpejqbalahwr\nyrkzavgdmdgtqpg",
        "expected_output": "3",
        "is_public": false
      },
      {
        "input_data": "a\na",
        "expected_output": "1",
        "is_public": false
      }
    ]
  },
  {
    "id": 188,
    "title": "Best Time to Buy and Sell Stock IV",
    "description": "You are given an integer array **prices** where `prices[i]` is the price of a given stock on the `ith` day, and an integer **k**.\n\nFind the maximum profit you can achieve. You may complete at most **k** transactions.",
    "input_format": "First line: Integer 'k'.\nSecond line: Integer 'n' (size of prices).\nThird line: 'n' space-separated integers.",
    "output_format": "Print the maximum profit.",
    "difficulty": "Hard",
    "tags": [
      "dp",
      "array"
    ],
    "solution": "### Observations\nIf `k >= n/2`, we can perform as many transactions as we want (infinite transaction case). Otherwise, we need a DP table tracking `k` transactions.\n\n### Approach\n1.  **State:** `dp[i][j]` = max profit on day `j` with at most `i` transactions.\n2.  **Transition:** `dp[i][j] = max(dp[i][j-1], price[j] + max_diff)`, where `max_diff` tracks the best buying opportunity `dp[i-1][prev] - price[prev]`.\n\n### Complexity Analysis\n- **Time:** O(k * n)\n- **Space:** O(k * n) or O(n) optimized.\n\n### Code Logic\n```python\ndef maxProfit(k, prices):\n    if not prices: return 0\n    n = len(prices)\n    if k >= n // 2: # Infinite transactions case\n        return sum(max(0, prices[i+1]-prices[i]) for i in range(n-1))\n    \n    dp = [[0] * n for _ in range(k + 1)]\n    for i in range(1, k + 1):\n        max_diff = -prices[0]\n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j-1], prices[j] + max_diff)\n            max_diff = max(max_diff, dp[i-1][j] - prices[j])\n    return dp[k][n-1]\n```",
    "hints": [
      "If k is very large (k >= n/2), the problem becomes 'Best Time to Buy and Sell Stock II'.",
      "Otherwise, use DP. Let `dp[i][j]` be the max profit using at most `i` transactions up to day `j`.",
      "The recurrence involves deciding whether to sell on day `j` or not.",
      "Optimize the inner loop by keeping a running maximum of (previous profit - purchase price)."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    try:\n        input_data = sys.stdin.read().split()\n        if not input_data: return\n        \n        k = int(input_data[0])\n        n = int(input_data[1])\n        if n == 0: \n            print(0)\n            return\n        prices = [int(x) for x in input_data[2:n+2]]\n        \n        if k >= n // 2:\n            print(sum(max(0, prices[i+1]-prices[i]) for i in range(n-1)))\n            return\n            \n        dp = [0] * n\n        for i in range(k):\n            max_diff = -prices[0]\n            prev_dp = list(dp) # copy previous transaction row\n            for j in range(1, n):\n                dp[j] = max(dp[j-1], prices[j] + max_diff)\n                max_diff = max(max_diff, prev_dp[j] - prices[j])\n        \n        print(dp[n-1])\n    except Exception:\n        return\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (!sc.hasNext()) return;\n        int k = sc.nextInt();\n        int n = sc.nextInt();\n        int[] prices = new int[n];\n        for(int i=0; i<n; i++) prices[i] = sc.nextInt();\n        \n        if (n == 0) {\n            System.out.println(0);\n            return;\n        }\n\n        if (k >= n / 2) {\n            int profit = 0;\n            for (int i = 1; i < n; i++) \n                if (prices[i] > prices[i-1]) profit += prices[i] - prices[i-1];\n            System.out.println(profit);\n            return;\n        }\n\n        int[] dp = new int[n];\n        for (int i = 0; i < k; i++) {\n            int maxDiff = -prices[0];\n            int[] nextDp = new int[n];\n            for (int j = 1; j < n; j++) {\n                nextDp[j] = Math.max(nextDp[j-1], prices[j] + maxDiff);\n                maxDiff = Math.max(maxDiff, dp[j] - prices[j]);\n            }\n            dp = nextDp;\n        }\n        System.out.println(dp[n-1]);\n    }\n}",
    "test_cases": [
      {
        "input_data": "2\n3\n2 4 1",
        "expected_output": "2",
        "is_public": true
      },
      {
        "input_data": "2\n6\n3 2 6 5 0 3",
        "expected_output": "7",
        "is_public": true
      },
      {
        "input_data": "0\n3\n1 2 3",
        "expected_output": "0",
        "is_public": false
      },
      {
        "input_data": "2\n2\n3 1",
        "expected_output": "0",
        "is_public": false
      },
      {
        "input_data": "2\n5\n1 2 4 2 5",
        "expected_output": "6",
        "is_public": false
      },
      {
        "input_data": "100\n4\n1 2 4 7",
        "expected_output": "6",
        "is_public": false
      }
    ]
  },
  {
    "id": 312,
    "title": "Burst Balloons",
    "description": "You are given `n` balloons, indexed from `0` to `n - 1`. Each balloon is painted with a number on it represented by an array **nums**.\n\nYou are asked to burst all the balloons. If you burst the `ith` balloon, you will get `nums[i - 1] * nums[i] * nums[i + 1]` coins. If `i - 1` or `i + 1` goes out of bounds of the array, then treat it as if there is a balloon with a **1** painted on it.\n\nReturn the maximum coins you can collect by bursting the balloons wisely.",
    "input_format": "First line: Integer 'n'.\nSecond line: 'n' space-separated integers.",
    "output_format": "Print the maximum coins.",
    "difficulty": "Hard",
    "tags": [
      "dp",
      "array"
    ],
    "solution": "### Observations\nThinking forward (which balloon to burst first) splits the array into dependent problems. Thinking **backward** (which balloon to burst *last*) splits the array into independent subproblems. The last balloon to burst will be multiplied by the boundaries.\n\n### Approach (Interval DP)\n1.  Add `1` to the start and end of `nums`.\n2.  `dp[i][j]` = max coins from bursting balloons strictly between index `i` and `j`.\n3.  Loop length `l` from 2 to `n+2`.\n4.  Iterate left bound `i`, right bound `j`. Pick last burst balloon `k` between `i` and `j`.\n5.  `dp[i][j] = max(dp[i][k] + dp[k][j] + nums[i]*nums[k]*nums[j])`.\n\n### Complexity Analysis\n- **Time:** O(N^3)\n- **Space:** O(N^2)\n\n### Code Logic\n```python\ndef maxCoins(nums):\n    nums = [1] + nums + [1]\n    n = len(nums)\n    dp = [[0] * n for _ in range(n)]\n\n    for length in range(2, n):\n        for left in range(n - length):\n            right = left + length\n            for k in range(left + 1, right):\n                dp[left][right] = max(\n                    dp[left][right], \n                    nums[left] * nums[k] * nums[right] + dp[left][k] + dp[k][right]\n                )\n    return dp[0][n-1]\n```",
    "hints": [
      "Don't think about which balloon to burst first. Think about which one to burst LAST.",
      "If balloon `k` is the last one to burst in the range (i, j), its neighbors will be `i` and `j`.",
      "Pad the array with 1 at both ends to handle edge cases easily.",
      "This is Matrix Chain Multiplication (MCM) style Interval DP."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    try:\n        input_data = sys.stdin.read().split()\n        if not input_data: return\n        \n        n = int(input_data[0])\n        nums = [int(x) for x in input_data[1:n+1]]\n        \n        # Padding\n        nums = [1] + nums + [1]\n        new_n = len(nums)\n        dp = [[0] * new_n for _ in range(new_n)]\n        \n        for length in range(2, new_n):\n            for left in range(new_n - length):\n                right = left + length\n                for k in range(left + 1, right):\n                    coins = nums[left] * nums[k] * nums[right]\n                    coins += dp[left][k] + dp[k][right]\n                    dp[left][right] = max(dp[left][right], coins)\n                    \n        print(dp[0][new_n - 1])\n    except Exception:\n        return\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (!sc.hasNext()) return;\n        int n = sc.nextInt();\n        int[] raw = new int[n];\n        for(int i=0; i<n; i++) raw[i] = sc.nextInt();\n        \n        int[] nums = new int[n + 2];\n        nums[0] = 1;\n        nums[n + 1] = 1;\n        System.arraycopy(raw, 0, nums, 1, n);\n        \n        int newN = nums.length;\n        int[][] dp = new int[newN][newN];\n        \n        for (int length = 2; length < newN; length++) {\n            for (int left = 0; left < newN - length; left++) {\n                int right = left + length;\n                for (int k = left + 1; k < right; k++) {\n                    int val = nums[left] * nums[k] * nums[right];\n                    val += dp[left][k] + dp[k][right];\n                    dp[left][right] = Math.max(dp[left][right], val);\n                }\n            }\n        }\n        \n        System.out.println(dp[0][newN - 1]);\n    }\n}",
    "test_cases": [
      {
        "input_data": "4\n3 1 5 8",
        "expected_output": "167",
        "is_public": true
      },
      {
        "input_data": "2\n1 5",
        "expected_output": "10",
        "is_public": true
      },
      {
        "input_data": "1\n5",
        "expected_output": "5",
        "is_public": false
      },
      {
        "input_data": "3\n9 76 64",
        "expected_output": "49536",
        "is_public": false
      },
      {
        "input_data": "5\n3 1 5 8 2",
        "expected_output": "227",
        "is_public": false
      },
      {
        "input_data": "6\n8 2 6 8 9 5",
        "expected_output": "3630",
        "is_public": false
      }
    ]
  },
  {
    "id": 10,
    "title": "Regular Expression Matching",
    "description": "Given an input string `s` and a pattern `p`, implement regular expression matching with support for `.` and `*` where:\n- `.` Matches any single character.\n- `*` Matches zero or more of the preceding element.\n\nThe matching should cover the **entire** input string (not partial).",
    "input_format": "First line: String 's'.\nSecond line: String 'p'.",
    "output_format": "Print 'true' or 'false'.",
    "difficulty": "Hard",
    "tags": [
      "string",
      "dp"
    ],
    "solution": "### Observations\nThe `*` is tricky because it looks back at the previous character in the pattern. It can eliminate the previous char (0 occurrences) or repeat it (1+ occurrences).\n\n### Approach\n1.  **State:** `dp[i][j]` = Does `s[:i]` match `p[:j]`?\n2.  **Base Case:** `dp[0][0] = True` (empty matches empty). Handle patterns like `a*b*` matching empty.\n3.  **Transition:**\n    -   If `p[j-1]` is char or `.`: `dp[i][j] = dp[i-1][j-1]` (if char matches).\n    -   If `p[j-1]` is `*`: \n        -   Match 0 times: `dp[i][j-2]`.\n        -   Match 1+ times: `dp[i-1][j]` (provided `s[i-1]` matches the char before `*`).\n\n### Complexity Analysis\n- **Time:** O(N * M)\n- **Space:** O(N * M)\n\n### Code Logic\n```python\ndef isMatch(s, p):\n    dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n    dp[0][0] = True\n    \n    # Handle patterns like a* or a*b*\n    for j in range(2, len(p) + 1):\n        if p[j-1] == '*':\n            dp[0][j] = dp[0][j-2]\n            \n    for i in range(1, len(s) + 1):\n        for j in range(1, len(p) + 1):\n            if p[j-1] == '*':\n                dp[i][j] = dp[i][j-2] # 0 occurences\n                if p[j-2] == '.' or p[j-2] == s[i-1]:\n                    dp[i][j] |= dp[i-1][j]\n            elif p[j-1] == '.' or p[j-1] == s[i-1]:\n                dp[i][j] = dp[i-1][j-1]\n                \n    return dp[len(s)][len(p)]\n```",
    "hints": [
      "Use DP. `dp[i][j]` represents if s[0..i] matches p[0..j].",
      "Pay attention to the '*' character. It relates to the character *before* it.",
      "For `*`, you have two choices: ignore the `char*` part (match 0 times), or use it to match the current character in `s` (match 1+ times).",
      "Initialize base cases for empty strings. `a*` can match an empty string."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    try:\n        input_data = sys.stdin.read().split()\n        # Handle empty string inputs\n        if len(input_data) == 0: s, p = \"\", \"\"\n        elif len(input_data) == 1: s, p = input_data[0], \"\"\n        else: s, p = input_data[0], input_data[1]\n        \n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n        \n        for j in range(2, n + 1):\n            if p[j-1] == '*':\n                dp[0][j] = dp[0][j-2]\n                \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j-1] == '*':\n                    dp[i][j] = dp[i][j-2]\n                    if p[j-2] == '.' or p[j-2] == s[i-1]:\n                        dp[i][j] = dp[i][j] or dp[i-1][j]\n                elif p[j-1] == '.' or p[j-1] == s[i-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                    \n        print(\"true\" if dp[m][n] else \"false\")\n    except Exception:\n        return\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.hasNext() ? sc.next() : \"\";\n        String p = sc.hasNext() ? sc.next() : \"\";\n        \n        int m = s.length();\n        int n = p.length();\n        boolean[][] dp = new boolean[m + 1][n + 1];\n        dp[0][0] = true;\n        \n        for (int j = 2; j <= n; j++) {\n            if (p.charAt(j - 1) == '*') {\n                dp[0][j] = dp[0][j - 2];\n            }\n        }\n        \n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (p.charAt(j - 1) == '*') {\n                    dp[i][j] = dp[i][j - 2];\n                    if (p.charAt(j - 2) == '.' || p.charAt(j - 2) == s.charAt(i - 1)) {\n                        dp[i][j] = dp[i][j] || dp[i - 1][j];\n                    }\n                } else if (p.charAt(j - 1) == '.' || p.charAt(j - 1) == s.charAt(i - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                }\n            }\n        }\n        \n        System.out.println(dp[m][n] ? \"true\" : \"false\");\n    }\n}",
    "test_cases": [
      {
        "input_data": "aa\na",
        "expected_output": "false",
        "is_public": true
      },
      {
        "input_data": "aa\na*",
        "expected_output": "true",
        "is_public": true
      },
      {
        "input_data": "ab\n.*",
        "expected_output": "true",
        "is_public": true
      },
      {
        "input_data": "aab\nc*a*b",
        "expected_output": "true",
        "is_public": false
      },
      {
        "input_data": "mississippi\nmis*is*p*.",
        "expected_output": "false",
        "is_public": false
      },
      {
        "input_data": "ab\n.*c",
        "expected_output": "false",
        "is_public": false
      }
    ]
  }
]