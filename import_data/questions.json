[
  {
  "id": 2,
  "title": "Two Sum",
  "difficulty": "Easy",
  "tags": ["array", "two_pointers"],
  "description": "Given an array of integers **nums** and an integer **target**, return the indices of the two numbers such that they add up to **target**.\n\nYou may assume that each input would have **exactly one solution**, and you may not use the same element twice.\n\nYou can return the answer in any order, but for this judge, print the indices sorted in ascending order (e.g., `0 1`).\n\n### Example 1\n```\nInput:\n4\n2 7 11 15\n9\n\nOutput:\n0 1\nExplanation: Because nums[0] + nums[1] == 9, we return 0 1.\n```\n\n### Constraints\n* $2 \\le nums.length \\le 10^4$\n* $-10^9 \\le nums[i] \\le 10^9$\n* $-10^9 \\le target \\le 10^9$\n* **Only one valid answer exists.**",
  "input_format": "First line: An integer N (size of the array).\nSecond line: N space-separated integers representing the array nums.\nThird line: An integer target.",
  "output_format": "Two space-separated integers representing the indices of the two numbers, sorted in ascending order.",
  "solution": "### Observations\nThe problem asks us to find two numbers $a$ and $b$ in an array such that $a + b = target$. This is equivalent to finding a number $b$ such that $b = target - a$. \n\n### Approach 1: Brute Force\nThe simplest approach is to check every pair of numbers. We can loop through each element $x$ and for each element, loop through the rest of the array to see if there is a value that equals $target - x$.\n\n* **Time Complexity:** $O(N^2)$ because of the nested loops.\n* **Space Complexity:** $O(1)$.\n\n### Approach 2: Hash Map (Optimized)\nTo improve efficiency, we can reduce the lookup time. As we iterate through the array, we want to know if the complement ($target - current\\_value$) has typically already been seen. \n\nWe can use a **Hash Map** (Dictionary in Python) to store the mapping of `value -> index`. \n\n1.  Initialize an empty hash map.\n2.  Iterate through the array with index $i$ and value $num$.\n3.  Calculate `complement = target - num`.\n4.  Check if `complement` exists in the hash map.\n    * If yes, we found the pair! Return the index stored in the map and current index $i$.\n    * If no, store the current number and its index in the map: `map[num] = i`.\n\n### Complexity Analysis\n* **Time Complexity:** $O(N)$. We traverse the list containing $N$ elements exactly once. Each look up in the table costs only $O(1)$ on average.\n* **Space Complexity:** $O(N)$. The extra space required depends on the number of items stored in the hash table, which stores at most $N$ elements.\n\n### Python Logic\n```python\ndef solve(nums, target):\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []\n```\n\n### Java Logic\n```java\npublic int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        int complement = target - nums[i];\n        if (map.containsKey(complement)) {\n            return new int[] { map.get(complement), i };\n        }\n        map.put(nums[i], i);\n    }\n    return new int[] {};\n}\n```",
  "hints": [
    "Is there a way to check if the 'pair' of the current number exists without scanning the whole array again?",
    "If x + y = target, then y = target - x. For every x, you need to find y.",
    "A Hash Map can store values you have already seen and their indices, allowing for O(1) retrieval.",
    "Iterate through the array once. For each element, check if its complement is already in your Hash Map."
  ],
  "boilerplate_python": "import sys\n\ndef solve():\n    # Read N\n    try:\n        input_data = sys.stdin.read().split()\n    except Exception:\n        return\n\n    if not input_data:\n        return\n\n    iterator = iter(input_data)\n    try:\n        n = int(next(iterator))\n        nums = [int(next(iterator)) for _ in range(n)]\n        target = int(next(iterator))\n    except StopIteration:\n        return\n\n    # Write your logic here to find indices\n    # print(f\"{idx1} {idx2}\")\n\nif __name__ == \"__main__\":\n    solve()",
  "boilerplate_java": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        if (scanner.hasNextInt()) {\n            int n = scanner.nextInt();\n            int[] nums = new int[n];\n            for (int i = 0; i < n; i++) {\n                nums[i] = scanner.nextInt();\n            }\n            if (scanner.hasNextInt()) {\n                int target = scanner.nextInt();\n                solve(nums, target);\n            }\n        }\n        scanner.close();\n    }\n\n    private static void solve(int[] nums, int target) {\n        // Write your logic here\n        // System.out.println(index1 + \" \" + index2);\n    }\n}",
  "test_cases": [
    {
      "input_data": "4\n2 7 11 15\n9",
      "expected_output": "0 1",
      "is_public": true
    },
    {
      "input_data": "3\n3 2 4\n6",
      "expected_output": "1 2",
      "is_public": true
    },
    {
      "input_data": "2\n3 3\n6",
      "expected_output": "0 1",
      "is_public": false
    },
    {
      "input_data": "4\n-1 -2 -3 -4\n-7",
      "expected_output": "2 3",
      "is_public": false
    },
    {
      "input_data": "5\n0 4 3 0 1\n0",
      "expected_output": "0 3",
      "is_public": false
    },
    {
      "input_data": "2\n-1000000000 1000000000\n0",
      "expected_output": "0 1",
      "is_public": false
    },
    {
      "input_data": "10\n1 2 3 4 5 6 7 8 9 10\n19",
      "expected_output": "8 9",
      "is_public": false
    }
  ]
},
{
  "id": 33,
  "title": "Search in Rotated Sorted Array",
  "difficulty": "Medium",
  "tags": ["sorting","binary_search"],
  "description": "There is an integer array **nums** sorted in ascending order (with distinct values). \n\nPrior to being passed to your function, **nums** is possibly rotated at an unknown pivot index $k$ ($1 \\le k < nums.length$) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (0-indexed).\n\nFor example, `[0,1,2,4,5,6,7]` might be rotated at pivot index 3 and become `[4,5,6,7,0,1,2]`.\n\nGiven the array **nums** after the possible rotation and an integer **target**, return the index of **target** if it is in **nums**, or `-1` if it is not in **nums**.\n\nYou must write an algorithm with $O(\\log n)$ runtime complexity.\n\n### Example 1\n```\nInput:\n7\n4 5 6 7 0 1 2\n0\n\nOutput:\n4\n```\n\n### Constraints\n* $1 \\le nums.length \\le 5000$\n* $-10^4 \\le nums[i] \\le 10^4$\n* All values of **nums** are **unique**.\n* **nums** is an ascending array that is possibly rotated.\n* $-10^4 \\le target \\le 10^4$",
  "input_format": "First line: An integer N (size of the array).\nSecond line: N space-separated integers representing the array nums.\nThird line: An integer target.",
  "output_format": "A single integer representing the index of the target, or -1 if not found.",
  "solution": "### Observations\nThe problem requires a time complexity of $O(\\log n)$, which strongly suggests a Binary Search approach. However, the array is rotated, so we cannot apply standard Binary Search directly because the entire array isn't sorted.\n\nHowever, if we split the array into two halves using a midpoint, **one half is guaranteed to be sorted**.\n\n### Approach: Modified Binary Search\n1.  Initialize `left = 0` and `right = n - 1`.\n2.  Loop while `left <= right`:\n    * Calculate `mid = (left + right) // 2`.\n    * If `nums[mid] == target`, return `mid`.\n    * **Identify the sorted half:**\n        * **Case A: Left half is sorted** (`nums[left] <= nums[mid]`)\n            * Check if the `target` lies within this sorted range: `nums[left] <= target < nums[mid]`.\n            * If yes, move `right = mid - 1`.\n            * Otherwise, the target must be in the right half: `left = mid + 1`.\n        * **Case B: Right half is sorted** (`nums[mid] < nums[right]`)\n            * Check if the `target` lies within this sorted range: `nums[mid] < target <= nums[right]`.\n            * If yes, move `left = mid + 1`.\n            * Otherwise, the target must be in the left half: `right = mid - 1`.\n3.  If the loop ends, return `-1`.\n\n### Complexity Analysis\n* **Time Complexity:** $O(\\log N)$. We cut the search space in half at every step.\n* **Space Complexity:** $O(1)$. We only use a few variables for pointers.\n\n### Python Logic\n```python\ndef solve(nums, target):\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        \n        # Check if left half is sorted\n        if nums[left] <= nums[mid]:\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        # Otherwise, right half must be sorted\n        else:\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n    return -1\n```\n\n### Java Logic\n```java\npublic int search(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) return mid;\n\n        if (nums[left] <= nums[mid]) {\n            // Left half is sorted\n            if (nums[left] <= target && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            // Right half is sorted\n            if (nums[mid] < target && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n```",
  "hints": [
    "Even though the array is rotated, at least one half (left or right) of the array will always be sorted relative to the midpoint.",
    "Use a modified binary search. Determine which side is sorted first.",
    "If the left side is sorted, check if the target falls within the range [nums[left], nums[mid]]. If it does, search left; otherwise, search right.",
    "If the right side is sorted, check if the target falls within the range [nums[mid], nums[right]]."
  ],
  "boilerplate_python": "import sys\n\ndef solve():\n    # Read inputs\n    input_data = sys.stdin.read().split()\n    if not input_data: return\n    iterator = iter(input_data)\n\n    try:\n        n = int(next(iterator))\n        nums = [int(next(iterator)) for _ in range(n)]\n        target = int(next(iterator))\n        \n        # Implement your search logic here\n        result = -1\n        # result = search(nums, target)\n        print(result)\n    except StopIteration:\n        return\n\nif __name__ == \"__main__\":\n    solve()",
  "boilerplate_java": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        if (scanner.hasNextInt()) {\n            int n = scanner.nextInt();\n            int[] nums = new int[n];\n            for (int i = 0; i < n; i++) {\n                nums[i] = scanner.nextInt();\n            }\n            if (scanner.hasNextInt()) {\n                int target = scanner.nextInt();\n                System.out.println(search(nums, target));\n            }\n        }\n    }\n\n    public static int search(int[] nums, int target) {\n        // Your code here\n        return -1;\n    }\n}",
  "test_cases": [
    {
      "input_data": "7\n4 5 6 7 0 1 2\n0",
      "expected_output": "4",
      "is_public": true
    },
    {
      "input_data": "7\n4 5 6 7 0 1 2\n3",
      "expected_output": "-1",
      "is_public": true
    },
    {
      "input_data": "1\n1\n0",
      "expected_output": "-1",
      "is_public": false
    },
    {
      "input_data": "1\n1\n1",
      "expected_output": "0",
      "is_public": false
    },
    {
      "input_data": "2\n3 1\n1",
      "expected_output": "1",
      "is_public": false
    },
    {
      "input_data": "2\n3 1\n3",
      "expected_output": "0",
      "is_public": false
    },
    {
      "input_data": "5\n1 2 3 4 5\n5",
      "expected_output": "4",
      "is_public": false
    },
    {
      "input_data": "5\n5 1 2 3 4\n5",
      "expected_output": "0",
      "is_public": false
    },
    {
      "input_data": "6\n4 5 6 1 2 3\n2",
      "expected_output": "4",
      "is_public": false
    }
  ]
},
{
  "id": 56,
  "title": "Merge Intervals",
  "difficulty": "Medium",
  "tags": ["sorting","array"],
  "description": "Given an array of **intervals** where `intervals[i] = [start, end]`, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n\n### Example 1\n```\nInput:\n4\n1 3\n2 6\n8 10\n15 18\n\nOutput:\n1 6\n8 10\n15 18\nExplanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n```\n\n### Example 2\n```\nInput:\n2\n1 4\n4 5\n\nOutput:\n1 5\nExplanation: Intervals [1,4] and [4,5] are considered overlapping.\n```\n\n### Constraints\n* $1 \\le intervals.length \\le 10^4$\n* $intervals[i].length == 2$\n* $0 \\le start_i \\le end_i \\le 10^4$",
  "input_format": "First line: An integer N (number of intervals).\nNext N lines: Two space-separated integers start and end.",
  "output_format": "Print each merged interval on a new line as two space-separated integers.",
   "solution": "### Observations\nThe key observation is that if we sort the intervals by their **start time**, we can process them sequentially. If an interval starts before the previous one ends, they must overlap (or touch) and can be merged.\n\n### Approach\n1. **Sort**: Sort the intervals based on the start time: $O(N \\log N)$.\n2. **Iterate**: Create a list `merged` and add the first interval to it.\n3. For each subsequent interval `curr`:\n    * Let `last` be the last interval in `merged`.\n    * If `curr.start <= last.end`, they overlap. We merge them by updating `last.end = max(last.end, curr.end)`.\n    * Otherwise, they don't overlap. Add `curr` to `merged`.\n\n### Complexity Analysis\n* **Time Complexity:** $O(N \\log N)$ due to sorting.\n* **Space Complexity:** $O(N)$ (or $O(\\log N)$ depending on the sorting implementation's stack usage).\n\n### Python Logic\n```python\ndef solve(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = []\n    for interval in intervals:\n        if not merged or merged[-1][1] < interval[0]:\n            merged.append(interval)\n        else:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n    return merged\n```\n\n### Java Logic\n```java\npublic int[][] merge(int[][] intervals) {\n    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n    LinkedList<int[]> merged = new LinkedList<>();\n    for (int[] interval : intervals) {\n        if (merged.isEmpty() || merged.getLast()[1] < interval[0]) {\n            merged.add(interval);\n        } else {\n            merged.getLast()[1] = Math.max(merged.getLast()[1], interval[1]);\n        }\n    }\n    return merged.toArray(new int[merged.size()][]);\n}\n```",  "hints": [
    "If the intervals are sorted by their start times, can you process them one by one?",
    "If interval A overlaps with interval B, and B overlaps with C, does A overlap with C? (Transitivity)",
    "Keep track of the 'current' merged interval. Update its end time if the next interval starts before the current one ends."
  ],
  "boilerplate_python": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data: return\n    iterator = iter(input_data)\n\n    try:\n        n = int(next(iterator))\n        intervals = []\n        for _ in range(n):\n            start = int(next(iterator))\n            end = int(next(iterator))\n            intervals.append([start, end])\n            \n        # Logic to merge intervals\n        # result = merge(intervals)\n        # for interval in result:\n        #     print(f\"{interval[0]} {interval[1]}\")\n            \n    except StopIteration:\n        return\n\nif __name__ == \"__main__\":\n    solve()",
  "boilerplate_java": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        if (scanner.hasNextInt()) {\n            int n = scanner.nextInt();\n            int[][] intervals = new int[n][2];\n            for (int i = 0; i < n; i++) {\n                intervals[i][0] = scanner.nextInt();\n                intervals[i][1] = scanner.nextInt();\n            }\n            \n            // Call merge logic and print\n        }\n    }\n}",
  "test_cases": [
    {
      "input_data": "4\n1 3\n2 6\n8 10\n15 18",
      "expected_output": "1 6\n8 10\n15 18",
      "is_public": true
    },
    {
      "input_data": "2\n1 4\n4 5",
      "expected_output": "1 5",
      "is_public": true
    },
    {
      "input_data": "1\n1 4",
      "expected_output": "1 4",
      "is_public": false
    },
    {
      "input_data": "3\n1 4\n2 3\n6 7",
      "expected_output": "1 4\n6 7",
      "is_public": false
    },
    {
      "input_data": "3\n1 4\n0 4\n3 5",
      "expected_output": "0 5",
      "is_public": false
    },
    {
      "input_data": "3\n1 10\n2 3\n4 5",
      "expected_output": "1 10",
      "is_public": false
    },
    {
      "input_data": "5\n1 2\n3 4\n5 6\n7 8\n9 10",
      "expected_output": "1 2\n3 4\n5 6\n7 8\n9 10",
      "is_public": false
    }
  ]
},
{
  "id": 238,
  "title": "Product of Array Except Self",
  "difficulty": "Medium",
  "tags": ["math","array"],
  "description": "Given an integer array **nums**, return an array **answer** such that `answer[i]` is equal to the product of all the elements of **nums** except `nums[i]`.\n\nThe product of any prefix or suffix of **nums** is guaranteed to fit in a **32-bit** integer.\n\n**You must write an algorithm that runs in $O(N)$ time and without using the division operation.**\n\n### Example 1\n```\nInput:\n4\n1 2 3 4\n\nOutput:\n24 12 8 6\n```\n\n### Example 2\n```\nInput:\n5\n-1 1 0 -3 3\n\nOutput:\n0 0 9 0 0\n```\n\n### Constraints\n* $2 \\le nums.length \\le 10^5$\n* $-30 \\le nums[i] \\le 30$",
  "input_format": "First line: An integer N.\nSecond line: N space-separated integers.",
  "output_format": "Space-separated integers representing the result array.",
  "solution": "### Observations\nWe need `ans[i] = product(nums[0]...nums[i-1]) * product(nums[i+1]...nums[n-1])`.\nThis implies that for any index `i`, the result is the product of all elements to the **left** of `i` multiplied by the product of all elements to the **right** of `i`.\n\n### Approach 1: Left and Right Arrays ($O(N)$ Space)\n1.  Create an array `L` where `L[i]` contains the product of all elements to the left of `i`.\n2.  Create an array `R` where `R[i]` contains the product of all elements to the right of `i`.\n3.  `ans[i] = L[i] * R[i]`.\n\n### Approach 2: Constant Space Optimization ($O(1)$ Extra Space)\nInstead of creating two separate arrays, we can use the output array `ans` to store the left products first.\n1.  Pass 1 (Left): `ans[i]` stores product of `nums[0]...nums[i-1]`.\n2.  Pass 2 (Right): Maintain a variable `R` (running product from the right). Update `ans[i] = ans[i] * R`, then update `R = R * nums[i]`.\n\n### Complexity Analysis\n* **Time Complexity:** $O(N)$. Two passes over the array.\n* **Space Complexity:** $O(1)$ (excluding the output array).\n\n### Python Logic\n```python\ndef solve(nums):\n    length = len(nums)\n    answer = [0]*length\n\n    # Left pass\n    answer[0] = 1\n    for i in range(1, length):\n        answer[i] = nums[i - 1] * answer[i - 1]\n\n    # Right pass\n    R = 1\n    for i in reversed(range(length)):\n        answer[i] = answer[i] * R\n        R *= nums[i]\n\n    return answer\n```\n\n### Java Logic\n```java\npublic int[] productExceptSelf(int[] nums) {\n    int n = nums.length;\n    int[] res = new int[n];\n    res[0] = 1;\n    // Left pass\n    for (int i = 1; i < n; i++) {\n        res[i] = res[i - 1] * nums[i - 1];\n    }\n    // Right pass\n    int right = 1;\n    for (int i = n - 1; i >= 0; i--) {\n        res[i] = res[i] * right;\n        right *= nums[i];\n    }\n    return res;\n}\n```",
  "hints": [
    "Think about the problem as finding the product of elements to the LEFT of index i, and elements to the RIGHT of index i.",
    "Can you calculate the 'Left Product' for all elements in one pass?",
    "Can you do the same for the 'Right Product' in a second pass?",
    "You can save space by storing the Left Product in the result array and updating it on the fly with the Right Product."
  ],
  "boilerplate_python": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data: return\n    iterator = iter(input_data)\n\n    try:\n        n = int(next(iterator))\n        nums = [int(next(iterator)) for _ in range(n)]\n        \n        # Your logic here\n        # print(*(result))\n        \n    except StopIteration:\n        return\n\nif __name__ == \"__main__\":\n    solve()",
  "boilerplate_java": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        if (scanner.hasNextInt()) {\n            int n = scanner.nextInt();\n            int[] nums = new int[n];\n            for (int i = 0; i < n; i++) {\n                nums[i] = scanner.nextInt();\n            }\n            \n            // Logic here\n            // System.out.print(val + \" \");\n        }\n    }\n}",
  "test_cases": [
    {
      "input_data": "4\n1 2 3 4",
      "expected_output": "24 12 8 6",
      "is_public": true
    },
    {
      "input_data": "5\n-1 1 0 -3 3",
      "expected_output": "0 0 9 0 0",
      "is_public": true
    },
    {
      "input_data": "2\n0 0",
      "expected_output": "0 0",
      "is_public": false
    },
    {
      "input_data": "3\n1 0 2",
      "expected_output": "0 2 0",
      "is_public": false
    },
    {
      "input_data": "3\n5 5 5",
      "expected_output": "25 25 25",
      "is_public": false
    },
    {
      "input_data": "5\n2 3 4 5 6",
      "expected_output": "360 240 180 144 120",
      "is_public": false
    },
    {
      "input_data": "6\n1 -1 1 -1 1 -1",
      "expected_output": "-1 1 -1 1 -1 1",
      "is_public": false
    }
  ]
},
{
  "id": 128,
  "title": "Longest Consecutive Sequence",
  "difficulty": "Medium",
  "tags": ["sorting","array"],
  "description": "Given an unsorted array of integers **nums**, return the length of the longest consecutive elements sequence.\n\nFor example, if the input is `[100, 4, 200, 1, 3, 2]`, the longest consecutive elements sequence is `[1, 2, 3, 4]`. Therefore its length is 4.\n\n**You must write an algorithm that runs in $O(N)$ time.**\n\n### Example 1\n```\nInput:\n6\n100 4 200 1 3 2\n\nOutput:\n4\n```\n\n### Example 2\n```\nInput:\n10\n0 3 7 2 5 8 4 6 0 1\n\nOutput:\n9\n```\n\n### Constraints\n* $0 \\le nums.length \\le 10^5$\n* $-10^9 \\le nums[i] \\le 10^9$",
  "input_format": "First line: An integer N.\nSecond line: N space-separated integers.",
  "output_format": "A single integer representing the length of the longest consecutive sequence.",
  "solution": "### Observations\nA naive approach would be to sort the array, which takes $O(N \\log N)$. However, the requirement is $O(N)$. This suggests we need a Hash Set or Hash Map for $O(1)$ lookups.\n\n### Approach: Hash Set\n1.  **Insert all numbers into a HashSet**. This allows $O(1)$ existence checks and removes duplicates.\n2.  **Iterate through the Set**. For each number `num`:\n    * Check if `num - 1` exists in the set.\n    * **If `num - 1` exists**: It means `num` is NOT the start of a sequence. We can skip it because the sequence starting at `num - 1` (or earlier) will cover it.\n    * **If `num - 1` does NOT exist**: `num` is the start of a new sequence.\n        * Start counting: check if `num + 1`, `num + 2`, ... exist in the set.\n        * Update the global `longest_streak` max.\n\n### Complexity Analysis\n* **Time Complexity:** $O(N)$. Although there is a `while` loop inside the `for` loop, each number is visited at most twice (once to add to set, once to build the sequence).\n* **Space Complexity:** $O(N)$ for the HashSet.\n\n### Python Logic\n```python\ndef solve(nums):\n    num_set = set(nums)\n    longest_streak = 0\n\n    for num in num_set:\n        if num - 1 not in num_set:\n            current_num = num\n            current_streak = 1\n\n            while current_num + 1 in num_set:\n                current_num += 1\n                current_streak += 1\n\n            longest_streak = max(longest_streak, current_streak)\n\n    return longest_streak\n```\n\n### Java Logic\n```java\npublic int longestConsecutive(int[] nums) {\n    Set<Integer> numSet = new HashSet<>();\n    for (int num : nums) {\n        numSet.add(num);\n    }\n\n    int longestStreak = 0;\n\n    for (int num : numSet) {\n        if (!numSet.contains(num - 1)) {\n            int currentNum = num;\n            int currentStreak = 1;\n\n            while (numSet.contains(currentNum + 1)) {\n                currentNum += 1;\n                currentStreak += 1;\n            }\n\n            longestStreak = Math.max(longestStreak, currentStreak);\n        }\n    }\n\n    return longestStreak;\n}\n```",
  "hints": [
    "Sorting takes O(N log N). Can you use a Set to get O(1) access?",
    "If you have a number `x`, how do you know if it's the START of a sequence?",
    "A number `x` is the start of a sequence if `x-1` is NOT in the set.",
    "Only start counting the length of the sequence if you are at the start of it."
  ],
  "boilerplate_python": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data: return\n    iterator = iter(input_data)\n\n    try:\n        n = int(next(iterator))\n        nums = [int(next(iterator)) for _ in range(n)]\n        \n        # Your logic here\n        # print(result)\n        \n    except StopIteration:\n        return\n\nif __name__ == \"__main__\":\n    solve()",
  "boilerplate_java": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        if (scanner.hasNextInt()) {\n            int n = scanner.nextInt();\n            int[] nums = new int[n];\n            for (int i = 0; i < n; i++) {\n                nums[i] = scanner.nextInt();\n            }\n            \n            // Logic here\n            // System.out.println(ans);\n        }\n    }\n}",
  "test_cases": [
    {
      "input_data": "6\n100 4 200 1 3 2",
      "expected_output": "4",
      "is_public": true
    },
    {
      "input_data": "10\n0 3 7 2 5 8 4 6 0 1",
      "expected_output": "9",
      "is_public": true
    },
    {
      "input_data": "0\n",
      "expected_output": "0",
      "is_public": false
    },
    {
      "input_data": "1\n10",
      "expected_output": "1",
      "is_public": false
    },
    {
      "input_data": "5\n2 2 2 2 2",
      "expected_output": "1",
      "is_public": false
    },
    {
      "input_data": "5\n10 1 11 2 12",
      "expected_output": "3",
      "is_public": false
    },
    {
      "input_data": "10\n1 9 2 8 3 7 4 6 5 100",
      "expected_output": "9",
      "is_public": false
    }
  ]
},
{
  "id": 42,
  "title": "Trapping Rain Water",
  "difficulty": "Medium",
  "tags": ["two_pointers","array"],
  "description": "Given `n` non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n\n### Example 1\n```\nInput:\n12\n0 1 0 2 1 0 1 3 2 1 2 1\n\nOutput:\n6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n```\n\n### Constraints\n* $n == height.length$\n* $1 \\le n \\le 2 \\times 10^4$\n* $0 \\le height[i] \\le 10^5$",
  "input_format": "First line: An integer N.\nSecond line: N space-separated integers representing heights.",
  "output_format": "A single integer representing the total amount of trapped water.",
  "solution": "### Observations\nFor any index `i`, the amount of water it can hold is determined by the maximum height of bars to its left and the maximum height of bars to its right. specifically:\n`water[i] = min(max_left[i], max_right[i]) - height[i]`\nIf the result is negative, it holds 0 water.\n\n### Approach 1: Dynamic Programming\nPrecompute `max_left` and `max_right` arrays.\n1. `max_left[i]`: Max height from index 0 to `i`.\n2. `max_right[i]`: Max height from index `n-1` down to `i`.\n3. Iterate and sum up `min(max_left[i], max_right[i]) - height[i]`.\n\n### Approach 2: Two Pointers (Optimized)\nWe can save space by using two pointers, `left` and `right`. We maintain `left_max` and `right_max`.\n1.  If `height[left] < height[right]`: \n    * If `height[left] >= left_max`, update `left_max`.\n    * Else, add `left_max - height[left]` to result.\n    * Move `left` forward.\n2.  Else:\n    * If `height[right] >= right_max`, update `right_max`.\n    * Else, add `right_max - height[right]` to result.\n    * Move `right` backward.\n\n### Complexity Analysis\n* **Time Complexity:** $O(N)$. We scan the array once.\n* **Space Complexity:** $O(1)$ for Two Pointers, $O(N)$ for Dynamic Programming.\n\n### Python Logic\n```python\ndef solve(height):\n    if not height: return 0\n    l, r = 0, len(height) - 1\n    left_max, right_max = height[l], height[r]\n    res = 0\n    \n    while l < r:\n        if left_max < right_max:\n            l += 1\n            left_max = max(left_max, height[l])\n            res += left_max - height[l]\n        else:\n            r -= 1\n            right_max = max(right_max, height[r])\n            res += right_max - height[r]\n    return res\n```\n\n### Java Logic\n```java\npublic int trap(int[] height) {\n    int left = 0, right = height.length - 1;\n    int ans = 0;\n    int left_max = 0, right_max = 0;\n    while (left < right) {\n        if (height[left] < height[right]) {\n            if (height[left] >= left_max) left_max = height[left];\n            else ans += (left_max - height[left]);\n            ++left;\n        } else {\n            if (height[right] >= right_max) right_max = height[right];\n            else ans += (right_max - height[right]);\n            --right;\n        }\n    }\n    return ans;\n}\n```",
  "hints": [
    "For a specific bar, how much water can be trapped on top of it?",
    "It depends on the highest bar to its left and the highest bar to its right.",
    "Water at index i = min(max_left, max_right) - height[i].",
    "Can you compute max_left and max_right for every position efficiently?",
    "Try using two pointers to calculate the trapped water in one pass without extra space."
  ],
  "boilerplate_python": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data: return\n    iterator = iter(input_data)\n\n    try:\n        n = int(next(iterator))\n        height = [int(next(iterator)) for _ in range(n)]\n        \n        # Your logic here\n        # print(ans)\n        \n    except StopIteration:\n        return\n\nif __name__ == \"__main__\":\n    solve()",
  "boilerplate_java": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        if (scanner.hasNextInt()) {\n            int n = scanner.nextInt();\n            int[] height = new int[n];\n            for (int i = 0; i < n; i++) {\n                height[i] = scanner.nextInt();\n            }\n            \n            // Logic here\n            // System.out.println(ans);\n        }\n    }\n}",
  "test_cases": [
    {
      "input_data": "12\n0 1 0 2 1 0 1 3 2 1 2 1",
      "expected_output": "6",
      "is_public": true
    },
    {
      "input_data": "6\n4 2 0 3 2 5",
      "expected_output": "9",
      "is_public": true
    },
    {
      "input_data": "3\n1 2 3",
      "expected_output": "0",
      "is_public": false
    },
    {
      "input_data": "3\n3 2 1",
      "expected_output": "0",
      "is_public": false
    },
    {
      "input_data": "5\n3 0 0 0 3",
      "expected_output": "9",
      "is_public": false
    },
    {
      "input_data": "5\n0 0 0 0 0",
      "expected_output": "0",
      "is_public": false
    },
    {
      "input_data": "7\n5 1 1 5 1 1 5",
      "expected_output": "16",
      "is_public": false
    }
  ]
},
{
  "id": 53,
  "title": "Maximum Subarray",
  "difficulty": "Medium",
  "tags": ["sorting","array"],
  "description": "Given an integer array **nums**, find the contiguous subarray (containing at least one number) which has the largest sum and return *its sum*.\n\nA **subarray** is a contiguous part of an array.\n\n### Example 1\n```\nInput:\n9\n-2 1 -3 4 -1 2 1 -5 4\n\nOutput:\n6\nExplanation: The subarray [4,-1,2,1] has the largest sum = 6.\n```\n\n### Example 2\n```\nInput:\n1\n1\n\nOutput:\n1\n```\n\n### Example 3\n```\nInput:\n5\n5 4 -1 7 8\n\nOutput:\n23\n```\n\n### Constraints\n* $1 \\le nums.length \\le 10^5$\n* $-10^4 \\le nums[i] \\le 10^4$",
  "input_format": "First line: An integer N.\nSecond line: N space-separated integers.",
  "output_format": "A single integer representing the maximum subarray sum.",
  "solution": "### Observations\nA brute force approach would check every possible subarray sum, which takes $O(N^2)$ time. Given $N=10^5$, this will time out. We need an $O(N)$ solution.\n\nThe core insight is: If we are building a sum of a subarray and the sum becomes **negative**, carrying that negative sum forward will only decrease the sum of any future subarray. Therefore, if the current running sum drops below zero, it is better to reset the running sum to zero (or start a new subarray at the next element).\n\n### Approach: Kadane's Algorithm\nWe iterate through the array while maintaining two variables:\n1.  `current_sum`: The maximum sum of the subarray ending at the current position.\n2.  `max_sum`: The global maximum sum found so far.\n\n**Algorithm:**\n1.  Initialize `max_sum` to the first element (to handle negative number arrays properly).\n2.  Initialize `current_sum` to 0 (or the first element).\n3.  Loop through each number `x` in `nums`:\n    * Update `current_sum = max(x, current_sum + x)`. This decision implies: \"Should I start a new subarray at `x`, or extend the existing subarray?\"\n    * Update `max_sum = max(max_sum, current_sum)`.\n4.  Return `max_sum`.\n\n### Complexity Analysis\n* **Time Complexity:** $O(N)$. We traverse the array exactly once.\n* **Space Complexity:** $O(1)$. Only two variables are used.\n\n### Python Logic\n```python\ndef solve(nums):\n    max_sum = nums[0]\n    current_sum = nums[0]\n    \n    for i in range(1, len(nums)):\n        # Either extend the previous subarray or start a new one\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n        \n    return max_sum\n```\n\n### Java Logic\n```java\npublic int maxSubArray(int[] nums) {\n    int maxSum = nums[0];\n    int currentSum = nums[0];\n    \n    for (int i = 1; i < nums.length; i++) {\n        currentSum = Math.max(nums[i], currentSum + nums[i]);\n        maxSum = Math.max(maxSum, currentSum);\n    }\n    return maxSum;\n}\n```",
  "hints": [
    "If the sum of a subarray is negative, does it help to include it in the next subarray?",
    "If 'current_sum' becomes negative, you should discard it and start fresh from the next element.",
    "Be careful with arrays containing only negative numbers. The answer should be the largest single negative number, not 0."
  ],
  "boilerplate_python": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data: return\n    iterator = iter(input_data)\n\n    try:\n        n = int(next(iterator))\n        nums = [int(next(iterator)) for _ in range(n)]\n        \n        # Your logic here\n        # print(result)\n        \n    except StopIteration:\n        return\n\nif __name__ == \"__main__\":\n    solve()",
  "boilerplate_java": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        if (scanner.hasNextInt()) {\n            int n = scanner.nextInt();\n            int[] nums = new int[n];\n            for (int i = 0; i < n; i++) {\n                nums[i] = scanner.nextInt();\n            }\n            \n            // Logic here\n            // System.out.println(result);\n        }\n    }\n}",
  "test_cases": [
    {
      "input_data": "9\n-2 1 -3 4 -1 2 1 -5 4",
      "expected_output": "6",
      "is_public": true
    },
    {
      "input_data": "1\n1",
      "expected_output": "1",
      "is_public": true
    },
    {
      "input_data": "5\n5 4 -1 7 8",
      "expected_output": "23",
      "is_public": true
    },
    {
      "input_data": "2\n-2 -1",
      "expected_output": "-1",
      "is_public": false
    },
    {
      "input_data": "3\n-1 -2 -3",
      "expected_output": "-1",
      "is_public": false
    },
    {
      "input_data": "5\n-5 -4 -3 -2 -1",
      "expected_output": "-1",
      "is_public": false
    },
    {
      "input_data": "6\n1 2 -5 4 5 -2",
      "expected_output": "9",
      "is_public": false
    }
  ]
},
{
  "id": 739,
  "title": "Daily Temperatures",
  "description": "Given an array of integers **temperatures** represents the daily temperatures, return an array **answer** such that **answer[i]** is the number of days you have to wait after the `i-th` day to get a warmer temperature.\n\nIf there is no future day for which this is possible, keep **answer[i]** == 0.\n\n### Example 1\n**Input:** `temperatures = [73,74,75,71,69,72,76,73]`\n**Output:** `[1,1,4,2,1,1,0,0]`\n\n### Example 2\n**Input:** `temperatures = [30,40,50,60]`\n**Output:** `[1,1,1,0]`\n\n### Constraints\n* `1 <= temperatures.length <= 10^5`\n* `30 <= temperatures[i] <= 100`",
  "input_format": "First line: An integer N representing the number of days.\nSecond line: N space-separated integers representing the daily temperatures.",
  "output_format": "A single line containing N space-separated integers representing the number of days to wait.",
  "difficulty": "Medium",
  "tags": [
    "stacks",
    "array"
  ],
  "solution": "### Observations\nTo find the next warmer day for each day, a brute force approach would involve looking ahead for every single element, resulting in $O(N^2)$ time complexity. However, we notice that we are essentially looking for the **Next Greater Element**. If we keep a history of unresolved days (days for which we haven't found a warmer day yet), we can resolve them as soon as we encounter a current temperature that is higher.\n\n### Approach: Monotonic Stack\n1.  Initialize an array `answer` of size `N` with 0s.\n2.  Use a **stack** to store indices of the `temperatures` array. This stack will maintain indices of temperatures in a **decreasing** order (monotonic stack).\n3.  Iterate through the `temperatures` array with index `curr_day` and temperature `curr_temp`:\n    * While the stack is not empty and `curr_temp` is greater than the temperature at the index stored at the top of the stack (`stack.peek()`):\n        * This means `curr_day` is the warmer day for the day at `stack.peek()`.\n        * Pop the index `prev_day` from the stack.\n        * Calculate the wait time: `answer[prev_day] = curr_day - prev_day`.\n    * Push `curr_day` onto the stack.\n4.  Any indices remaining in the stack have no future warmer day, so their value in `answer` remains 0.\n\n### Complexity Analysis\n* **Time Complexity:** $O(N)$. Each element is pushed onto the stack once and popped at most once.\n* **Space Complexity:** $O(N)$ for the stack and the output array.\n\n### Code Logic\n\n**Python Logic**\n```python\nstack = [] # Stores indices\nres = [0] * n\n\nfor i, t in enumerate(temperatures):\n    while stack and t > temperatures[stack[-1]]:\n        stack_ind = stack.pop()\n        res[stack_ind] = i - stack_ind\n    stack.append(i)\n# Print res formatted\n```\n\n**Java Logic**\n```java\nStack<Integer> stack = new Stack<>();\nint[] res = new int[n];\n\nfor (int i = 0; i < n; i++) {\n    while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {\n        int idx = stack.pop();\n        res[idx] = i - idx;\n    }\n    stack.push(i);\n}\n// Print res formatted\n```",
  "hints": [
    "Consider iterating through the array while keeping track of indices you haven't found an answer for yet.",
    "If the current temperature is warmer than a previous day's temperature, you can calculate the waiting days for that previous day immediately.",
    "A stack can help you store indices of days with temperatures that are decreasing. This is known as a Monotonic Stack.",
    "Store indices in the stack, not the temperature values, so you can calculate the distance `current_index - stored_index`."
  ],
  "boilerplate_python": "import sys\n\ndef solve():\n    # Read N\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n\n    iterator = iter(input_data)\n    try:\n        n = int(next(iterator))\n        temperatures = []\n        for _ in range(n):\n            temperatures.append(int(next(iterator)))\n    except StopIteration:\n        return\n\n    # Write your code here\n    # result = ...\n\n    # print(*(result))\n\nif __name__ == '__main__':\n    solve()",
  "boilerplate_java": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        \n        String line = br.readLine();\n        if (line == null || line.isEmpty()) return;\n        \n        int n = Integer.parseInt(line.trim());\n        int[] temperatures = new int[n];\n        \n        String[] parts = br.readLine().trim().split(\"\\\\s+\");\n        for(int i = 0; i < n; i++) {\n            temperatures[i] = Integer.parseInt(parts[i]);\n        }\n        \n        // Write your logic here\n        // int[] result = ...\n        \n        /* \n        StringBuilder sb = new StringBuilder();\n        for(int i : result) sb.append(i).append(\" \");\n        out.println(sb.toString().trim());\n        */\n        \n        out.flush();\n    }\n}",
  "test_cases": [
    {
      "input_data": "8\n73 74 75 71 69 72 76 73",
      "expected_output": "1 1 4 2 1 1 0 0",
      "is_public": true
    },
    {
      "input_data": "4\n30 40 50 60",
      "expected_output": "1 1 1 0",
      "is_public": true
    },
    {
      "input_data": "3\n30 60 90",
      "expected_output": "1 1 0",
      "is_public": true
    },
    {
      "input_data": "1\n50",
      "expected_output": "0",
      "is_public": false
    },
    {
      "input_data": "5\n90 80 70 60 50",
      "expected_output": "0 0 0 0 0",
      "is_public": false
    },
    {
      "input_data": "6\n89 62 70 58 47 76",
      "expected_output": "0 1 3 2 1 0",
      "is_public": false
    },
    {
      "input_data": "10\n34 33 32 31 30 50 29 28 27 60",
      "expected_output": "5 4 3 2 1 4 3 2 1 0",
      "is_public": false
    },
    {
      "input_data": "2\n30 29",
      "expected_output": "0 0",
      "is_public": false
    },
    {
      "input_data": "5\n50 50 50 50 50",
      "expected_output": "0 0 0 0 0",
      "is_public": false
    },
    {
      "input_data": "12\n100 99 98 90 91 92 93 30 40 50 60 101",
      "expected_output": "11 10 9 1 1 1 5 1 1 1 1 0",
      "is_public": false
    }
  ]
},
{
  "id": 155,
  "title": "Min Stack",
  "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\nImplement the `MinStack` class:\n* `push(val)` pushes the element **val** onto the stack.\n* `pop()` removes the element on the top of the stack.\n* `top()` gets the top element of the stack.\n* `getMin()` retrieves the minimum element in the stack.\n\n**Note:** You must implement a solution with `O(1)` time complexity for each function.",
  "input_format": "First line: An integer Q representing the number of queries.\nNext Q lines: A string representing the command. If the command is \"push\", it is followed by an integer X.",
  "output_format": "For each `top` or `getMin` command, print the result on a new line.",
  "difficulty": "Medium",
  "tags": [
    "stacks"
  ],
  "solution": "### Observations\nA standard stack supports `push`, `pop`, and `top` in $O(1)$. The challenge is `getMin`. A naive approach might scan the stack for the minimum, taking $O(N)$. To achieve $O(1)$, we must store the minimum information *at the time of insertion*.\n\n### Approach: Two Stacks\nWe can use two stacks:\n1.  **Main Stack:** Stores the actual values.\n2.  **Min Stack:** Stores the minimum value encountered *so far*.\n\n**Logic:**\n* **Push(x):** Push `x` to the Main Stack. Push `min(x, MinStack.top())` to the Min Stack. This ensures the top of the Min Stack always represents the minimum of the current sequence.\n* **Pop:** Pop from both stacks. This keeps them synchronized.\n* **Top:** Return Main Stack top.\n* **GetMin:** Return Min Stack top.\n\n### Complexity Analysis\n* **Time Complexity:** $O(1)$ for all operations.\n* **Space Complexity:** $O(N)$ to store the auxiliary stack.\n\n### Code Logic\n\n**Python Logic**\n```python\nclass MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n\n    def push(self, val):\n        self.stack.append(val)\n        # If min_stack is empty or val is smaller/equal to current min, push val\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n        else:\n            # Duplicate the current min to keep stacks aligned (optional variant)\n            # Or just don't push, but need to handle pop carefully.\n            # Easiest: Push min(val, current_min)\n            self.min_stack.append(self.min_stack[-1])\n            \n    def pop(self):\n        self.stack.pop()\n        self.min_stack.pop()\n\n    def top(self):\n        return self.stack[-1]\n\n    def getMin(self):\n        return self.min_stack[-1]\n```",
  "hints": [
    "Consider using an auxiliary stack to keep track of the minimums.",
    "When you push a new value, check if it's smaller than the current minimum. If so, that's the new minimum.",
    "The top of the auxiliary stack should always represent the minimum element of the main stack at that specific height.",
    "Ensure that when you pop from the main stack, you also update the minimum state (by popping from the auxiliary stack)."
  ],
  "boilerplate_python": "import sys\n\n# Implement your class here\nclass MinStack:\n    def __init__(self):\n        pass\n\n    def push(self, val: int):\n        pass\n\n    def pop(self):\n        pass\n\n    def top(self) -> int:\n        pass\n\n    def getMin(self) -> int:\n        pass\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    iterator = iter(input_data)\n    \n    try:\n        q = int(next(iterator))\n        obj = MinStack()\n        for _ in range(q):\n            cmd = next(iterator)\n            if cmd == \"push\":\n                val = int(next(iterator))\n                obj.push(val)\n            elif cmd == \"pop\":\n                obj.pop()\n            elif cmd == \"top\":\n                print(obj.top())\n            elif cmd == \"getMin\":\n                print(obj.getMin())\n    except StopIteration:\n        pass\n\nif __name__ == '__main__':\n    solve()",
  "boilerplate_java": "import java.io.*;\nimport java.util.*;\n\nclass MinStack {\n    public MinStack() {\n        \n    }\n    \n    public void push(int val) {\n        \n    }\n    \n    public void pop() {\n        \n    }\n    \n    public int top() {\n        return 0;\n    }\n    \n    public int getMin() {\n        return 0;\n    }\n}\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line = br.readLine();\n        if (line == null) return;\n        int n = Integer.parseInt(line.trim());\n        \n        MinStack obj = new MinStack();\n        \n        for (int i = 0; i < n; i++) {\n            String[] parts = br.readLine().trim().split(\" \");\n            String cmd = parts[0];\n            if (cmd.equals(\"push\")) {\n                obj.push(Integer.parseInt(parts[1]));\n            } else if (cmd.equals(\"pop\")) {\n                obj.pop();\n            } else if (cmd.equals(\"top\")) {\n                System.out.println(obj.top());\n            } else if (cmd.equals(\"getMin\")) {\n                System.out.println(obj.getMin());\n            }\n        }\n    }\n}",
  "test_cases": [
    {
      "input_data": "7\npush -2\npush 0\npush -3\ngetMin\npop\ntop\ngetMin",
      "expected_output": "-3\n0\n-2",
      "is_public": true
    },
    {
      "input_data": "5\npush 1\npush 2\ntop\ngetMin\npop",
      "expected_output": "2\n1",
      "is_public": true
    },
    {
      "input_data": "9\npush 2147483646\npush 2147483646\npush 2147483647\ntop\npop\ngetMin\npop\ngetMin\npop",
      "expected_output": "2147483647\n2147483646\n2147483646",
      "is_public": false
    },
    {
      "input_data": "6\npush -10\ngetMin\npush -20\ngetMin\npop\ngetMin",
      "expected_output": "-10\n-20\n-10",
      "is_public": false
    },
    {
      "input_data": "4\npush 10\npush 5\npush 2\npush 1",
      "expected_output": "",
      "is_public": false
    },
    {
      "input_data": "10\npush 5\npush 4\npush 3\npush 2\npush 1\ngetMin\npop\ngetMin\npop\ngetMin",
      "expected_output": "1\n2\n3",
      "is_public": false
    }
  ]
},{
  "id": 84,
  "title": "Largest Rectangle in Histogram",
  "description": "Given an array of integers **heights** representing the histogram's bar height where the width of each bar is `1`, return the area of the largest rectangle in the histogram.\n\n### Example\n**Input:** `heights = [2,1,5,6,2,3]`\n**Output:** `10`\n**Explanation:** The largest rectangle has an area = 10 units (height 5, width 2).\n\n### Constraints\n* `1 <= heights.length <= 10^5`\n* `0 <= heights[i] <= 10^4`",
  "input_format": "First line: An integer N.\nSecond line: N space-separated integers.",
  "output_format": "A single integer representing the maximum area.",
  "difficulty": "Hard",
  "tags": [
    "array",
    "stacks"
  ],
  "solution": "### Observations\nFor any specific bar `i`, the largest rectangle that uses bar `i` as the *minimum height* is bounded by the first bar to the left that is smaller than `heights[i]` and the first bar to the right that is smaller than `heights[i]`.\n\n### Approach: Monotonic Stack\nWe need to find the **Nearest Smaller Element** to the left and right for every index.\n1.  Use a stack to store indices of the histogram bars. The stack will maintain indices in **increasing order of height**.\n2.  Iterate through the histogram. If the current bar is lower than the bar at the stack top, it means the bar at the stack top cannot extend further right.\n3.  **Process logic:**\n    * While `stack` is not empty and `current_height < heights[stack.top()]`:\n        * Pop the top index `h_idx`. This is the height of the candidate rectangle.\n        * The right boundary is the current index `i`.\n        * The left boundary is the new top of the stack (after popping). If the stack is empty, the width extends to index 0.\n        * `width = i - stack.top() - 1` (or `i` if stack is empty).\n        * `max_area = max(max_area, heights[h_idx] * width)`.\n    * Push current index `i`.\n4.  After the loop, process remaining bars in the stack (they extend to the end of the array).\n\n### Complexity Analysis\n* **Time Complexity:** $O(N)$ because every bar is pushed and popped exactly once.\n* **Space Complexity:** $O(N)$ for the stack.\n\n### Code Logic\n\n**Python Logic**\n```python\n# Append a 0 height at the end to flush the stack automatically\nheights.append(0)\nstack = [-1] # -1 acts as a sentinel for the left boundary\nmax_area = 0\n\nfor i, h in enumerate(heights):\n    while stack[-1] != -1 and h < heights[stack[-1]]:\n        height = heights[stack.pop()]\n        width = i - stack[-1] - 1\n        max_area = max(max_area, height * width)\n    stack.append(i)\n# Print max_area\n```",
  "hints": [
    "Think about what limits the width of a rectangle with a specific height `h`.",
    "For a bar at index `i` with height `h`, the rectangle can extend left until it hits a bar < `h`, and right until it hits a bar < `h`.",
    "This is a 'Nearest Smaller Element' problem. Can you use a Monotonic Stack?",
    "Consider adding a bar of height 0 at the end of the array to force pop all remaining elements from the stack."
  ],
  "boilerplate_python": "import sys\n\ndef solve():\n    # Read N\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n\n    iterator = iter(input_data)\n    try:\n        n = int(next(iterator))\n        heights = []\n        for _ in range(n):\n            heights.append(int(next(iterator)))\n    except StopIteration:\n        return\n\n    # Write your code here\n    # result = ...\n\n    # print(result)\n\nif __name__ == '__main__':\n    solve()",
  "boilerplate_java": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        \n        String line = br.readLine();\n        if (line == null || line.isEmpty()) return;\n        int n = Integer.parseInt(line.trim());\n        \n        int[] heights = new int[n];\n        String[] parts = br.readLine().trim().split(\"\\\\s+\");\n        for(int i = 0; i < n; i++) {\n            heights[i] = Integer.parseInt(parts[i]);\n        }\n        \n        // Write Logic Here\n        // long ans = ...\n        \n        // out.println(ans);\n        out.flush();\n    }\n}",
  "test_cases": [
    {
      "input_data": "6\n2 1 5 6 2 3",
      "expected_output": "10",
      "is_public": true
    },
    {
      "input_data": "2\n2 4",
      "expected_output": "4",
      "is_public": true
    },
    {
      "input_data": "1\n5",
      "expected_output": "5",
      "is_public": false
    },
    {
      "input_data": "5\n1 1 1 1 1",
      "expected_output": "5",
      "is_public": false
    },
    {
      "input_data": "5\n1 2 3 4 5",
      "expected_output": "9",
      "is_public": false
    },
    {
      "input_data": "5\n5 4 3 2 1",
      "expected_output": "9",
      "is_public": false
    },
    {
      "input_data": "6\n2 1 2 1 2 1",
      "expected_output": "6",
      "is_public": false
    },
    {
      "input_data": "3\n0 9 0",
      "expected_output": "9",
      "is_public": false
    },
    {
      "input_data": "4\n1000 1000 1000 1000",
      "expected_output": "4000",
      "is_public": false
    }
  ]
},
{
  "id": 200,
  "title": "Number of Islands",
  "description": "Given an `m x n` 2D binary grid **grid** which represents a map of **'1'**s (land) and **'0'**s (water), return the number of islands.\n\nAn **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
  "input_format": "First line: Two integers M and N representing rows and columns.\nNext M lines: N space-separated integers (0 or 1) representing the grid.",
  "output_format": "A single integer representing the number of islands.",
  "difficulty": "Medium",
  "tags": [
    "graph",
    "traversal",
    "array"
  ],
  "solution": "### Observations\nWe need to count connected components in a grid where connectivity is defined by horizontal or vertical adjacency. Since we need to visit every node to determine if it belongs to an unvisited island, this is a graph traversal problem.\n\n### Approach: DFS or BFS\n1.  Initialize a counter `count = 0`.\n2.  Iterate through every cell `(i, j)` in the grid.\n3.  If `grid[i][j] == '1'`, it means we found a new island:\n    * Increment `count`.\n    * Start a traversal (DFS or BFS) from `(i, j)` to find all connected land parts.\n    * During traversal, mark every visited '1' as '0' (or a special visited character like '#') to ensure we don't count it again.\n4.  Continue until all cells are processed.\n\n### Complexity Analysis\n* **Time Complexity:** $O(M \\times N)$. In the worst case, we visit every cell once.\n* **Space Complexity:** $O(M \\times N)$ in the worst case for the recursion stack (DFS) or queue (BFS) if the grid is filled with land.\n\n### Code Logic\n\n**Python Logic (DFS)**\n```python\ndef dfs(r, c):\n    if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] == '0':\n        return\n    grid[r][c] = '0' # Mark as visited\n    dfs(r+1, c)\n    dfs(r-1, c)\n    dfs(r, c+1)\n    dfs(r, c-1)\n\ncount = 0\nfor r in range(rows):\n    for c in range(cols):\n        if grid[r][c] == '1':\n            count += 1\n            dfs(r, c)\n# Print count\n```",
  "hints": [
    "You need to visit every '1' in the grid.",
    "When you find a '1', that is the start of an island. Increment your count.",
    "Once you find an island, you must 'sink' it (mark all connected '1's as visited) so you don't count parts of the same island again.",
    "You can use either DFS (recursion) or BFS (queue) to explore the island."
  ],
  "boilerplate_python": "import sys\n\n# Increase recursion depth for deep DFS\nsys.setrecursionlimit(20000)\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n\n    iterator = iter(input_data)\n    try:\n        m = int(next(iterator))\n        n = int(next(iterator))\n        grid = []\n        for _ in range(m):\n            row = []\n            for _ in range(n):\n                row.append(next(iterator))\n            grid.append(row)\n    except StopIteration:\n        return\n\n    # Write your code here\n    # result = ...\n\n    # print(result)\n\nif __name__ == '__main__':\n    solve()",
  "boilerplate_java": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line = br.readLine();\n        if (line == null) return;\n        \n        String[] dims = line.trim().split(\"\\\\s+\");\n        int m = Integer.parseInt(dims[0]);\n        int n = Integer.parseInt(dims[1]);\n        \n        char[][] grid = new char[m][n];\n        \n        for (int i = 0; i < m; i++) {\n            String[] parts = br.readLine().trim().split(\"\\\\s+\");\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = parts[j].charAt(0);\n            }\n        }\n        \n        // Write logic here\n        // int islands = ...\n        \n        // System.out.println(islands);\n    }\n}",
  "test_cases": [
    {
      "input_data": "4 5\n1 1 1 1 0\n1 1 0 1 0\n1 1 0 0 0\n0 0 0 0 0",
      "expected_output": "1",
      "is_public": true
    },
    {
      "input_data": "4 5\n1 1 0 0 0\n1 1 0 0 0\n0 0 1 0 0\n0 0 0 1 1",
      "expected_output": "3",
      "is_public": true
    },
    {
      "input_data": "1 1\n0",
      "expected_output": "0",
      "is_public": false
    },
    {
      "input_data": "1 1\n1",
      "expected_output": "1",
      "is_public": false
    },
    {
      "input_data": "3 3\n1 0 1\n0 1 0\n1 0 1",
      "expected_output": "5",
      "is_public": false
    },
    {
      "input_data": "3 3\n1 1 1\n1 1 1\n1 1 1",
      "expected_output": "1",
      "is_public": false
    },
    {
      "input_data": "5 5\n0 0 0 0 0\n0 0 0 0 0\n0 0 0 0 0\n0 0 0 0 0\n0 0 0 0 0",
      "expected_output": "0",
      "is_public": false
    }
  ]
},
{
  "id": 752,
  "title": "Open the Lock",
  "description": "You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: `'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'`. The wheels can rotate freely and wrap around: for example we can turn `'9'` to be `'0'`, or `'0'` to be `'9'`. Each move consists of turning one wheel one slot.\n\nThe lock initially starts at `'0000'`, a string representing the state of the 4 wheels.\n\nYou are given a list of `deadends` dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.\n\nGiven a `target` representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.",
  "input_format": "First line: The target string (e.g., \"0202\").\nSecond line: An integer D representing the number of deadends.\nThird line: D space-separated strings representing the deadends.",
  "output_format": "A single integer representing the minimum turns or -1.",
  "difficulty": "Medium",
  "tags": [
    "graph",
    "bfs",
    "queue",
    "set",
    "searching"
  ],
  "solution": "### Observations\nThis is a shortest path problem on a graph. Each lock state (e.g., \"0000\") is a node. An edge exists between two nodes if they differ by exactly one rotation on one wheel. Since we want the *minimum* number of turns, **Breadth-First Search (BFS)** is the ideal algorithm.\n\n### Approach: BFS\n1.  **State Representation:** Each combination \"0000\" to \"9999\" is a state.\n2.  **Validation:** Check if \"0000\" is in `deadends`. If so, return -1.\n3.  **Queue & Set:** Use a queue for BFS, initialized with `(\"0000\", 0)` (state, depth). Use a set `visited` initialized with `deadends` to avoid cycles and dead ends.\n4.  **Transitions:** For each digit in the current string, generate two new states: one by adding 1 (wrapping 9->0) and one by subtracting 1 (wrapping 0->9).\n5.  **Logic:**\n    * Pop `(current_code, turns)`.\n    * If `current_code == target`, return `turns`.\n    * Generate all 8 neighbors. If a neighbor hasn't been visited, add to queue and mark visited.\n\n### Complexity Analysis\n* **Time Complexity:** $O(A^N \\times N^2 + D)$, where $A$ is the alphabet size (10), $N$ is digits (4), and $D$ is the size of deadends. There are at most 10,000 states.\n* **Space Complexity:** $O(A^N)$ for the queue and visited set.\n\n### Code Logic\n\n**Python Logic**\n```python\nqueue = deque([('0000', 0)])\nvisited = set(deadends)\nif '0000' in visited: return -1\nvisited.add('0000')\n\nwhile queue:\n    curr, steps = queue.popleft()\n    if curr == target: return steps\n    \n    for i in range(4):\n        x = int(curr[i])\n        for move in [-1, 1]:\n            y = (x + move) % 10\n            # Form new string efficiently\n            new_code = curr[:i] + str(y) + curr[i+1:]\n            if new_code not in visited:\n                visited.add(new_code)\n                queue.append((new_code, steps + 1))\nreturn -1\n```",
  "hints": [
    "Think of the lock states as nodes in a graph. What are the edges?",
    "Since you need the MINIMUM number of moves, which graph traversal algorithm is best?",
    "Don't forget the 'deadends'. You can treat them as visited nodes right from the start so you never explore them.",
    "Handle the wrapping carefully: '0' - 1 becomes '9', and '9' + 1 becomes '0'."
  ],
  "boilerplate_python": "import sys\nfrom collections import deque\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n\n    iterator = iter(input_data)\n    try:\n        target = next(iterator)\n        d_count = int(next(iterator))\n        deadends = set()\n        for _ in range(d_count):\n            deadends.add(next(iterator))\n    except StopIteration:\n        return\n\n    # Write your code here\n    # result = ...\n\n    # print(result)\n\nif __name__ == '__main__':\n    solve()",
  "boilerplate_java": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String target = br.readLine();\n        if (target == null) return;\n        target = target.trim();\n        \n        String line2 = br.readLine();\n        if (line2 == null) return;\n        int d = Integer.parseInt(line2.trim());\n        \n        Set<String> deadends = new HashSet<>();\n        if (d > 0) {\n            String[] parts = br.readLine().trim().split(\"\\\\s+\");\n            for(String s : parts) deadends.add(s);\n        }\n        \n        // Write logic here\n        // int moves = ...\n        \n        // System.out.println(moves);\n    }\n}",
  "test_cases": [
    {
      "input_data": "0202\n5\n0201 0101 0102 1212 2002",
      "expected_output": "6",
      "is_public": true
    },
    {
      "input_data": "8888\n1\n0009",
      "expected_output": "1",
      "is_public": true
    },
    {
      "input_data": "8888\n8\n0000 8887 8889 8878 8898 8788 8988 7888 9888",
      "expected_output": "-1",
      "is_public": false
    },
    {
      "input_data": "0009\n1\n8888",
      "expected_output": "1",
      "is_public": false
    },
    {
      "input_data": "0000\n1\n8888",
      "expected_output": "0",
      "is_public": false
    },
    {
      "input_data": "1111\n2\n0000 2222",
      "expected_output": "-1",
      "is_public": false
    },
    {
      "input_data": "0000\n2\n0000 1111",
      "expected_output": "-1",
      "is_public": false
    },
    {
      "input_data": "9999\n1\n0000",
      "expected_output": "-1",
      "is_public": false
    }
  ]
},
{
  "id": 394,
  "title": "Decode String",
  "description": "Given an encoded string, return its decoded string.\n\nThe encoding rule is: `k[encoded_string]`, where the `encoded_string` inside the square brackets is being repeated exactly `k` times. Note that `k` is guaranteed to be a positive integer.\n\nYou may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, `k`.",
  "input_format": "A single line containing the encoded string S.",
  "output_format": "A single line containing the decoded string.",
  "difficulty": "Medium",
  "tags": [
    "stacks",
    "string",
    "recursion"
  ],
  "solution": "### Observations\nThis problem involves nested structures (e.g., `3[a2[c]]`), which naturally suggests using a **Stack** or **Recursion**. We need to process the innermost brackets first, which is exactly how a stack (LIFO) behaves.\n\n### Approach: Two Stacks\n1.  Use two stacks: `countStack` (to store the repeat numbers `k`) and `stringStack` (to store the string built *before* encountering the current `[`).\n2.  Iterate through the string:\n    * **Digit:** Build the number `k` (handle multi-digit numbers).\n    * **'[':** Push the current `k` to `countStack`. Push the `currentString` to `stringStack`. Reset `currentString` and `k`.\n    * **']':** We finished a segment. Pop `currentK` from `countStack`. Pop `decodedString` from `stringStack`. The new `currentString` becomes `decodedString + currentK * currentString`.\n    * **Character:** Append to `currentString`.\n\n### Complexity Analysis\n* **Time Complexity:** $O(\\text{maxK} \\times N)$, where maxK is the maximum repeat number and N is the length of the string. We construct the string potentially multiple times.\n* **Space Complexity:** $O(N)$ for the stacks and recursion depth.\n\n### Code Logic\n\n**Python Logic**\n```python\nstack = []\ncurr_str = \"\"\ncurr_num = 0\n\nfor char in s:\n    if char.isdigit():\n        curr_num = curr_num * 10 + int(char)\n    elif char == \"[\":\n        stack.append((curr_str, curr_num))\n        curr_str = \"\"\n        curr_num = 0\n    elif char == \"]\":\n        prev_str, num = stack.pop()\n        curr_str = prev_str + num * curr_str\n    else:\n        curr_str += char\n# Print curr_str\n```",
  "hints": [
    "This problem has a nested structure. Which data structure is best for handling nested elements (like parenthesis)?",
    "You encounter four types of characters: digits, letters, '[', and ']'. Handle each case separately.",
    "When you hit a '[', you need to remember the number you just read and the string you built so far. Push them to a stack.",
    "When you hit a ']', it means the current segment is done. Pop the number and the previous string from the stack and combine them."
  ],
  "boilerplate_python": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    \n    s = input_data[0]\n\n    # Write your code here\n    # result = ...\n\n    # print(result)\n\nif __name__ == '__main__':\n    solve()",
  "boilerplate_java": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String s = br.readLine();\n        if (s == null) return;\n        s = s.trim();\n        \n        // Write logic here\n        // String ans = ...\n        \n        // System.out.println(ans);\n    }\n}",
  "test_cases": [
    {
      "input_data": "3[a]2[bc]",
      "expected_output": "aaabcbc",
      "is_public": true
    },
    {
      "input_data": "3[a2[c]]",
      "expected_output": "accaccacc",
      "is_public": true
    },
    {
      "input_data": "2[abc]3[cd]ef",
      "expected_output": "abcabccdcdcdef",
      "is_public": true
    },
    {
      "input_data": "10[a]",
      "expected_output": "aaaaaaaaaa",
      "is_public": false
    },
    {
      "input_data": "1[a]",
      "expected_output": "a",
      "is_public": false
    },
    {
      "input_data": "2[2[2[a]]]",
      "expected_output": "aaaaaaaa",
      "is_public": false
    },
    {
      "input_data": "abc",
      "expected_output": "abc",
      "is_public": false
    }
  ]
},
{
  "id": 227,
  "title": "Basic Calculator II",
  "description": "Given a string `s` which represents an expression, evaluate this expression and return its value. \n\nThe integer division should truncate toward zero.\n\nYou may assume that the given expression is always valid. All intermediate results will be in the range of `[-2^31, 2^31 - 1]`.\n\n**Note:** You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as `eval()`.",
  "input_format": "A single line containing the expression string S.",
  "output_format": "A single integer representing the calculated value.",
  "difficulty": "Medium",
  "tags": [
    "stacks",
    "string",
    "array"
  ],
  "solution": "### Observations\nThe standard order of operations (PEMDAS) applies here, specifically multiplication and division take precedence over addition and subtraction. A simple left-to-right pass isn't enough because `1 + 2 * 3` should be `7`, not `9`.\n\n### Approach: Stack\n1.  Use a stack to store integers that need to be summed up at the end.\n2.  Maintain a `sign` variable (initialized to `+`) representing the operation *before* the current number.\n3.  Iterate through the string:\n    * If char is a digit, build the current number.\n    * If char is an operator `(+, -, *, /)` or we are at the end of the string:\n        * If `sign` was `+`: push `num` to stack.\n        * If `sign` was `-`: push `-num` to stack.\n        * If `sign` was `*`: pop top, multiply by `num`, push result.\n        * If `sign` was `/`: pop top, divide by `num` (integer division truncating towards zero), push result.\n        * Update `sign` to the current operator and reset `num` to 0.\n4.  Finally, sum up all values in the stack.\n\n### Complexity Analysis\n* **Time Complexity:** $O(N)$ - one pass through the string and one pass through the stack.\n* **Space Complexity:** $O(N)$ - to store the numbers in the stack.\n\n### Code Logic\n\n**Python Logic**\n```python\nstack = []\nnum = 0\nsign = '+'\n\nfor i, char in enumerate(s):\n    if char.isdigit():\n        num = num * 10 + int(char)\n    \n    if char in \"+-*/\" or i == len(s) - 1:\n        if sign == '+':\n            stack.append(num)\n        elif sign == '-':\n            stack.append(-num)\n        elif sign == '*':\n            stack.append(stack.pop() * num)\n        elif sign == '/':\n            # Python integer division floor vs truncate handling\n            top = stack.pop()\n            if top < 0:\n                stack.append(-(-top // num))\n            else:\n                stack.append(top // num)\n        sign = char\n        num = 0\nprint(sum(stack))\n```",
  "hints": [
    "Multiplication and division have higher precedence. You can't just process from left to right immediately adding/subtracting.",
    "Use a stack to hold numbers. If you see a `*` or `/`, process it immediately with the last number on the stack.",
    "If you see `+` or `-`, just push the number (or negative number) onto the stack to be added later.",
    "Be careful with integer division for negative numbers in Python (`-3 // 2` gives `-2`, but we want `-1`)."
  ],
  "boilerplate_python": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().splitlines()\n    if not input_data:\n        return\n    \n    s = input_data[0]\n\n    # Write your code here\n    # result = ...\n\n    # print(result)\n\nif __name__ == '__main__':\n    solve()",
  "boilerplate_java": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String s = br.readLine();\n        if (s == null) return;\n        \n        // Write logic here\n        // int result = ...\n        \n        // System.out.println(result);\n    }\n}",
  "test_cases": [
    {
      "input_data": "3+2*2",
      "expected_output": "7",
      "is_public": true
    },
    {
      "input_data": " 3/2 ",
      "expected_output": "1",
      "is_public": true
    },
    {
      "input_data": " 3+5 / 2 ",
      "expected_output": "5",
      "is_public": true
    },
    {
      "input_data": "1-1+1",
      "expected_output": "1",
      "is_public": false
    },
    {
      "input_data": "0",
      "expected_output": "0",
      "is_public": false
    },
    {
      "input_data": "42",
      "expected_output": "42",
      "is_public": false
    },
    {
      "input_data": "1000000*1",
      "expected_output": "1000000",
      "is_public": false
    },
    {
      "input_data": "14-3/2",
      "expected_output": "13",
      "is_public": false
    }
  ]
}
]