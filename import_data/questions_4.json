[
  {
    "id": 84,
    "title": "Largest Rectangle in Histogram",
    "description": "Given an array of integers **heights** representing the histogram's bar height where the width of each bar is 1, return the area of the *largest rectangle* in the histogram.\n\n### Example\nInput: heights = [2,1,5,6,2,3]\nOutput: 10\nExplanation: The largest rectangle has an area = 10 units.",
    "input_format": "The first line contains an integer **N**.\nThe second line contains **N** space-separated integers representing the **heights**.",
    "output_format": "Print a single integer representing the maximum area.",
    "difficulty": "Hard",
    "tags": [
      "array",
      "stacks"
    ],
    "solution": "### Observations\nThe core problem is finding the limits (left and right boundaries) for each bar where it can be the smallest bar in a rectangle. If we know the first index to the left that is smaller (`left_smaller`) and the first index to the right that is smaller (`right_smaller`), the width of the rectangle formed using the current bar as the full height is `right_smaller - left_smaller - 1`.\n\n### Approach\n1. **Brute Force:** For each bar, expand to the left and right until a smaller bar is found. Calculate area. Time: $O(N^2)$.\n2. **Monotonic Stack (Optimized):** \n   - We need to find the *Next Smaller Element* (NSE) and *Previous Smaller Element* (PSE) for every bar efficiently.\n   - Maintain a stack that keeps indices of bars with increasing heights.\n   - Iterate through the histogram. If the current bar is smaller than the bar at the stack top, it means the current bar is the 'Right Boundary' for the stack top.\n   - Pop the stack top. The new stack top (after popping) is the 'Left Boundary'.\n   - Calculate area for the popped bar: `height * (current_index - new_stack_top - 1)`.\n   - Push the current index.\n\n### Complexity Analysis\n- **Time Complexity:** $O(N)$, as each element is pushed and popped at most once.\n- **Space Complexity:** $O(N)$ for the stack.\n\n### Code Logic\n```python\ndef largestRectangleArea(heights):\n    stack = [] # pairs of (index, height)\n    max_area = 0\n    # Append a 0 height at the end to flush the stack\n    heights.append(0)\n    \n    for i, h in enumerate(heights):\n        start = i\n        while stack and stack[-1][1] > h:\n            index, height = stack.pop()\n            max_area = max(max_area, height * (i - index))\n            start = index\n        stack.append((start, h))\n        \n    return max_area\n```",
    "hints": [
      "Think about what limits the width of a rectangle with a specific height.",
      "For any bar `i`, the rectangle with height `heights[i]` extends to the left until it hits a bar smaller than `heights[i]`, and similarly to the right.",
      "Can you find the nearest smaller element to the left and right for every element efficiently?",
      "Try using a stack to keep track of increasing heights.",
      "When you encounter a bar smaller than the one at the top of the stack, you have found the right boundary for the stack top.",
      "The left boundary for the stack top is the element currently below it in the stack."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    # Reading input\n    input = sys.stdin.read().split()\n    if not input: return\n    n = int(input[0])\n    heights = list(map(int, input[1:n+1]))\n    \n    # Write your solution here\n    \nsolve()",
    "boilerplate_java": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line1 = br.readLine();\n        if (line1 == null) return;\n        int n = Integer.parseInt(line1.trim());\n        \n        int[] heights = new int[n];\n        String[] parts = br.readLine().trim().split(\"\\\\s+\");\n        for(int i=0; i<n; i++) {\n            heights[i] = Integer.parseInt(parts[i]);\n        }\n        \n        // Write your solution logic here\n        // System.out.println(result);\n    }\n}",
    "test_cases": [
      {
        "input_data": "6\n2 1 5 6 2 3",
        "expected_output": "10",
        "is_public": true
      },
      {
        "input_data": "2\n2 4",
        "expected_output": "4",
        "is_public": true
      },
      {
        "input_data": "1\n100",
        "expected_output": "100",
        "is_public": false
      },
      {
        "input_data": "5\n0 0 0 0 0",
        "expected_output": "0",
        "is_public": false
      },
      {
        "input_data": "5\n1 2 3 4 5",
        "expected_output": "9",
        "is_public": false
      },
      {
        "input_data": "5\n5 4 3 2 1",
        "expected_output": "9",
        "is_public": false
      },
      {
        "input_data": "7\n2 1 2 0 2 2 2",
        "expected_output": "6",
        "is_public": false
      },
      {
        "input_data": "6\n1 1 1 1 1 1",
        "expected_output": "6",
        "is_public": false
      }
    ]
  },
  {
    "id": 739,
    "title": "Daily Temperatures",
    "description": "Given an array of integers **temperatures** represents the daily temperatures, return an array **answer** such that **answer[i]** is the number of days you have to wait after the `i-th` day to get a warmer temperature. If there is no future day for which this is possible, keep **answer[i]** == 0.",
    "input_format": "The first line contains an integer **N**.\nThe second line contains **N** space-separated integers representing the **temperatures**.",
    "output_format": "Print **N** space-separated integers representing the waiting days.",
    "difficulty": "Medium",
    "tags": [
      "array",
      "stacks"
    ],
    "solution": "### Observations\nWe need to find the distance to the *next greater element* for each element in the array. A brute force approach would look ahead for every element, resulting in $O(N^2)$. We need a way to remember previous unsolved indices.\n\n### Approach\n1. **Monotonic Stack:** Use a stack to store indices of temperatures.\n2. Iterate through the list of temperatures.\n3. While the stack is not empty and the current temperature is greater than the temperature at the index stored at the top of the stack:\n   - This means we found a warmer day for the index at the stack top.\n   - Pop the index (`prev_index`).\n   - Calculate the wait time: `current_index - prev_index`.\n   - Store this in the result array at `prev_index`.\n4. Push the current index onto the stack.\n\n### Complexity Analysis\n- **Time Complexity:** $O(N)$. Each index is pushed and popped at most once.\n- **Space Complexity:** $O(N)$ for the stack.\n\n### Code Logic\n```python\ndef dailyTemperatures(T):\n    ans = [0] * len(T)\n    stack = [] # stores indices\n    \n    for i, t in enumerate(T):\n        while stack and T[stack[-1]] < t:\n            prev_index = stack.pop()\n            ans[prev_index] = i - prev_index\n        stack.append(i)\n    return ans\n```",
    "hints": [
      "If the temperature on day `i` is lower than day `j` (where `i < j`), day `i` is still waiting for a warmer day.",
      "Try to maintain a list of indices that haven't found a warmer day yet.",
      "Should this list of indices be ordered by temperature in increasing or decreasing order?",
      "A stack can help you track the indices of days with decreasing temperatures.",
      "When you see a temperature warmer than the stack's top, you can resolve the answer for that top index."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    # Reading input\n    input_data = sys.stdin.read().split()\n    if not input_data: return\n    n = int(input_data[0])\n    temps = list(map(int, input_data[1:n+1]))\n    \n    # Write logic here\n    \nsolve()",
    "boilerplate_java": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line1 = br.readLine();\n        if (line1 == null) return;\n        int n = Integer.parseInt(line1.trim());\n        \n        int[] temps = new int[n];\n        String[] parts = br.readLine().trim().split(\"\\\\s+\");\n        for(int i=0; i<n; i++) {\n            temps[i] = Integer.parseInt(parts[i]);\n        }\n        \n        // Write solution here\n        // System.out.print(...)\n    }\n}",
    "test_cases": [
      {
        "input_data": "4\n30 40 50 60",
        "expected_output": "1 1 1 0",
        "is_public": true
      },
      {
        "input_data": "8\n73 74 75 71 69 72 76 73",
        "expected_output": "1 1 4 2 1 1 0 0",
        "is_public": true
      },
      {
        "input_data": "3\n30 60 90",
        "expected_output": "1 1 0",
        "is_public": false
      },
      {
        "input_data": "4\n90 80 70 60",
        "expected_output": "0 0 0 0",
        "is_public": false
      },
      {
        "input_data": "5\n89 62 70 58 47",
        "expected_output": "0 1 0 0 0",
        "is_public": false
      },
      {
        "input_data": "6\n30 30 30 30 30 30",
        "expected_output": "0 0 0 0 0 0",
        "is_public": false
      },
      {
        "input_data": "6\n30 30 31 30 30 32",
        "expected_output": "2 1 3 2 1 0",
        "is_public": false
      }
    ]
  },
  {
    "id": 155,
    "title": "Min Stack",
    "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\nImplement the `MinStack` class:\n* `push(val)` pushes the element val onto the stack.\n* `pop()` removes the element on the top of the stack.\n* `top()` gets the top element of the stack.\n* `getMin()` retrieves the minimum element in the stack.\n\n**Note:** This is a design problem. The input simulates operations.",
    "input_format": "The first line contains an integer **N** (number of operations).\nThe next **N** lines contain operations: `push X`, `pop`, `top`, or `getMin`.",
    "output_format": "For `top` and `getMin` operations, print the result on a new line.",
    "difficulty": "Medium",
    "tags": [
      "stacks",
      "array"
    ],
    "solution": "### Observations\nThe standard stack operations are $O(1)$, but finding the minimum is usually $O(N)$. To achieve $O(1)$ for `getMin`, we need to store extra information.\n\n### Approach\n1. **Two Stacks:** \n   - Maintain a main stack for data.\n   - Maintain a `min_stack` that tracks the minimums encountered so far.\n2. **Push:**\n   - Always push to the main stack.\n   - If the `min_stack` is empty or the new value is $\\le$ the top of `min_stack`, push it to `min_stack` as well.\n3. **Pop:**\n   - Pop from the main stack.\n   - If the popped value is equal to the top of `min_stack`, pop from `min_stack` too.\n4. **GetMin:**\n   - Simply return the top of `min_stack`.\n\n### Complexity Analysis\n- **Time Complexity:** $O(1)$ for all operations.\n- **Space Complexity:** $O(N)$ for the auxiliary stack.\n\n### Code Logic\n```python\nclass MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n\n    def push(self, val):\n        self.stack.append(val)\n        # Push to min_stack if it's the new minimum\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self):\n        if self.stack:\n            val = self.stack.pop()\n            if val == self.min_stack[-1]:\n                self.min_stack.pop()\n\n    def top(self):\n        return self.stack[-1] if self.stack else None\n\n    def getMin(self):\n        return self.min_stack[-1] if self.min_stack else None\n```",
    "hints": [
      "Can you use an auxiliary data structure to keep track of the minimums?",
      "Consider a second stack that only pushes a value if it is smaller than or equal to the current minimum.",
      "When popping from the main stack, check if the value matches the top of the minimum stack.",
      "Space complexity will be O(N), but time complexity for getMin needs to be O(1)."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    lines = sys.stdin.read().splitlines()\n    if not lines: return\n    n = int(lines[0])\n    \n    stack = [] # Implement your stack logic here\n    # Aux variable or stack for min\n    \n    for i in range(1, n + 1):\n        parts = lines[i].split()\n        op = parts[0]\n        \n        if op == \"push\":\n            val = int(parts[1])\n            # Logic for push\n        elif op == \"pop\":\n            # Logic for pop\n            pass\n        elif op == \"top\":\n            # Print top\n            pass\n        elif op == \"getMin\":\n            # Print min\n            pass\n\nsolve()",
    "boilerplate_java": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (!sc.hasNextInt()) return;\n        int n = sc.nextInt();\n        \n        Stack<Integer> stack = new Stack<>();\n        Stack<Integer> minStack = new Stack<>();\n        \n        for (int i = 0; i < n; i++) {\n            String op = sc.next();\n            if (op.equals(\"push\")) {\n                int val = sc.nextInt();\n                stack.push(val);\n                if (minStack.isEmpty() || val <= minStack.peek()) {\n                    minStack.push(val);\n                }\n            } else if (op.equals(\"pop\")) {\n                int val = stack.pop();\n                if (val == minStack.peek()) {\n                    minStack.pop();\n                }\n            } else if (op.equals(\"top\")) {\n                System.out.println(stack.peek());\n            } else if (op.equals(\"getMin\")) {\n                System.out.println(minStack.peek());\n            }\n        }\n    }\n}",
    "test_cases": [
      {
        "input_data": "7\npush -2\npush 0\npush -3\ngetMin\npop\ntop\ngetMin",
        "expected_output": "-3\n0\n-2",
        "is_public": true
      },
      {
        "input_data": "5\npush 1\npush 2\ntop\ngetMin\npop",
        "expected_output": "2\n1",
        "is_public": true
      },
      {
        "input_data": "5\npush 2147483646\npush 2147483646\npush 2147483647\ntop\npop\ngetMin\npop\ngetMin\npop\npush 2147483647\ntop\ngetMin\npush -2147483648\ntop\ngetMin\npop\ngetMin",
        "expected_output": "2147483647\n2147483646\n2147483646\n2147483647\n2147483647\n-2147483648\n-2147483648\n2147483647",
        "is_public": false
      },
      {
        "input_data": "6\npush 10\npush 5\npush 5\npop\ngetMin\npop",
        "expected_output": "5",
        "is_public": false
      },
      {
        "input_data": "4\npush 1\npush 1\npush 1\ngetMin",
        "expected_output": "1",
        "is_public": false
      },
      {
        "input_data": "6\npush 10\npush 20\npush 5\ngetMin\npush 2\ngetMin",
        "expected_output": "5\n2",
        "is_public": false
      }
    ]
  },
  {
    "id": 227,
    "title": "Basic Calculator II",
    "description": "Given a string **s** which represents an expression, evaluate this expression and return its value. The integer division should truncate toward zero. The expression strings only contain non-negative integers, `+`, `-`, `*`, `/` operators, and empty spaces.",
    "input_format": "A single line containing the string **s**.",
    "output_format": "A single integer representing the result.",
    "difficulty": "Medium",
    "tags": [
      "stacks",
      "string"
    ],
    "solution": "### Observations\nStandard math rules apply: Multiplication and Division have higher precedence than Addition and Subtraction. We cannot simply evaluate left-to-right. We need to store numbers and process high-precedence operators immediately.\n\n### Approach\n1. **Using a Stack:**\n   - Initialize a `stack` to keep track of numbers to be summed up at the end.\n   - Keep track of the `last_operator` (initially `+`) and `current_number` (0).\n2. **Iteration:**\n   - Traverse the string char by char.\n   - If digit: update `current_number` (`num = num * 10 + digit`).\n   - If operator or end of string: \n     - Apply `last_operator` to `current_number` relative to the stack.\n     - If `+`: push `current_number`.\n     - If `-`: push `-current_number`.\n     - If `*`: pop top, multiply by `current_number`, push result.\n     - If `/`: pop top, divide by `current_number` (integer division truncating to zero), push result.\n     - Update `last_operator` to the current char and reset `current_number`.\n3. **Result:** Sum all elements in the stack.\n\n### Complexity Analysis\n- **Time Complexity:** $O(N)$ where N is string length.\n- **Space Complexity:** $O(N)$ for the stack.\n\n### Code Logic\n```python\ndef calculate(s):\n    stack = []\n    current_num = 0\n    op = '+'\n    s += '+' # sentinel to process last number\n    \n    for char in s:\n        if char.isdigit():\n            current_num = current_num * 10 + int(char)\n        elif char in '+-*/':\n            if op == '+':\n                stack.append(current_num)\n            elif op == '-':\n                stack.append(-current_num)\n            elif op == '*':\n                stack.append(stack.pop() * current_num)\n            elif op == '/':\n                top = stack.pop()\n                # Python integer division flooring issue handling\n                res = int(top / current_num)\n                stack.append(res)\n            op = char\n            current_num = 0\n            \n    return sum(stack)\n```",
    "hints": [
      "Scan the string from left to right.",
      "Keep a variable for the current number being built.",
      "Keep a variable for the LAST operator seen, not the current one.",
      "If the last operator was '*' or '/', you must evaluate it immediately against the last number on the stack.",
      "If the last operator was '+' or '-', just push the number (or negative number) to the stack.",
      "Finally, sum up the stack."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    s = sys.stdin.read().strip()\n    if not s: return\n    \n    # Write logic here\n    \nsolve()",
    "boilerplate_java": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String s = br.readLine();\n        if (s == null) return;\n        \n        // Write logic here\n        // System.out.println(result);\n    }\n}",
    "test_cases": [
      {
        "input_data": "3+2*2",
        "expected_output": "7",
        "is_public": true
      },
      {
        "input_data": " 3/2 ",
        "expected_output": "1",
        "is_public": true
      },
      {
        "input_data": " 3+5 / 2 ",
        "expected_output": "5",
        "is_public": true
      },
      {
        "input_data": "100-5",
        "expected_output": "95",
        "is_public": false
      },
      {
        "input_data": "1*2*3*4",
        "expected_output": "24",
        "is_public": false
      },
      {
        "input_data": "10-2*3",
        "expected_output": "4",
        "is_public": false
      },
      {
        "input_data": "14-3/2",
        "expected_output": "13",
        "is_public": false
      },
      {
        "input_data": "0-2147483647",
        "expected_output": "-2147483647",
        "is_public": false
      }
    ]
  },
  {
    "id": 394,
    "title": "Decode String",
    "description": "Given an encoded string, return its decoded string.\nThe encoding rule is: `k[encoded_string]`, where the encoded_string inside the square brackets is being repeated exactly `k` times. `k` is guaranteed to be a positive integer.\nYou may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc.\n\n### Example\n`3[a]2[bc]` -> `aaabcbc`",
    "input_format": "A single line containing the string **s**.",
    "output_format": "Print the decoded string.",
    "difficulty": "Medium",
    "tags": [
      "stacks",
      "string"
    ],
    "solution": "### Observations\nThis problem involves nested structures (brackets inside brackets), which suggests a Stack-based approach or Recursion. We need to process the inner-most brackets first.\n\n### Approach\n1. **Two Stacks (or One Compound Stack):** \n   - `count_stack`: to store the repeat numbers `k`.\n   - `str_stack`: to store the string built so far before encountering a `[`.\n2. **Iteration:**\n   - If digit: Build the number `k`.\n   - If `[`: Push the current `k` to `count_stack` and current `string` to `str_stack`. Reset `string` and `k`.\n   - If `]`: \n     - Pop `current_k` from `count_stack`.\n     - Pop `prev_string` from `str_stack`.\n     - Update `string = prev_string + (current_string * current_k)`.\n   - If char: Append to current `string`.\n\n### Complexity Analysis\n- **Time Complexity:** $O(\\text{size of output})$, as we construct the final string.\n- **Space Complexity:** $O(N)$ for stack depth.\n\n### Code Logic\n```python\ndef decodeString(s):\n    stack = []\n    curNum = 0\n    curString = ''\n    \n    for c in s:\n        if c == '[':\n            stack.append(curString)\n            stack.append(curNum)\n            curString = ''\n            curNum = 0\n        elif c == ']':\n            num = stack.pop()\n            prevString = stack.pop()\n            curString = prevString + num * curString\n        elif c.isdigit():\n            curNum = curNum * 10 + int(c)\n        else:\n            curString += c\n    return curString\n```",
    "hints": [
      "Use a stack to keep track of the current number and the string built before a bracket.",
      "When you encounter a `[`, you need to save the state (current number and current string) so you can start building the inner string.",
      "When you encounter a `]`, you finish the inner string. Retrieve the last saved number to repeat the inner string, and append it to the last saved string prefix.",
      "Remember that numbers can be more than one digit."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    s = sys.stdin.read().strip()\n    if not s: return\n    \n    # Write logic here\n    \nsolve()",
    "boilerplate_java": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String s = br.readLine();\n        if (s == null) return;\n        \n        // Write logic here\n        // System.out.println(result);\n    }\n}",
    "test_cases": [
      {
        "input_data": "3[a]2[bc]",
        "expected_output": "aaabcbc",
        "is_public": true
      },
      {
        "input_data": "3[a2[c]]",
        "expected_output": "accaccacc",
        "is_public": true
      },
      {
        "input_data": "2[abc]3[cd]ef",
        "expected_output": "abcabccdcdcdef",
        "is_public": true
      },
      {
        "input_data": "10[a]",
        "expected_output": "aaaaaaaaaa",
        "is_public": false
      },
      {
        "input_data": "2[3[a]b]",
        "expected_output": "aaabaaab",
        "is_public": false
      },
      {
        "input_data": "1[a]",
        "expected_output": "a",
        "is_public": false
      },
      {
        "input_data": "a",
        "expected_output": "a",
        "is_public": false
      }
    ]
  }
]