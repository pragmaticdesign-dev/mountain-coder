[
  {
    "id": 236,
    "title": "Lowest Common Ancestor of a Binary Tree",
    "description": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\n\nAccording to the definition of LCA on Wikipedia: \"The lowest common ancestor is defined between two nodes **p** and **q** as the lowest node in T that has both **p** and **q** as descendants (where we allow a node to be a descendant of itself).\"",
    "input_format": "First line: Space-separated values representing the tree in level-order (use 'null' for empty nodes).\nSecond line: Integer P (value of node p).\nThird line: Integer Q (value of node q).",
    "output_format": "Print the value of the LCA node.",
    "difficulty": "Medium",
    "tags": [
      "tree",
      "traversal"
    ],
    "solution": "### Observations\nWe need to find a node where **p** is in the left subtree and **q** is in the right (or vice versa), or the node is one of **p** or **q** itself.\n\n### Approach\n1. Start a recursive DFS.\n2. If current node is `null`, return `null`.\n3. If current node is **p** or **q**, return current node.\n4. Recurse left and right.\n5. If both left and right calls return a non-null value, the current node is the LCA.\n6. If only one side returns non-null, pass that value up.\n\n### Complexity Analysis\n* **Time:** $O(N)$ where N is number of nodes.\n* **Space:** $O(H)$ for recursion stack height.\n\n### Code Logic (Python)\n```python\ndef lca(root, p_val, q_val):\n    if not root or root.val == p_val or root.val == q_val:\n        return root\n    left = lca(root.left, p_val, q_val)\n    right = lca(root.right, p_val, q_val)\n    if left and right:\n        return root\n    return left if left else right\n```",
    "hints": [
      "Traverse the tree recursively.",
      "If you find p or q, return that node immediately.",
      "If a node receives non-null return values from both left and right subtrees, it is the LCA."
    ],
    "boilerplate_python": "import sys\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef build_tree(nodes):\n    if not nodes or nodes[0] == 'null': return None\n    root = TreeNode(int(nodes[0]))\n    queue = [root]\n    i = 1\n    while i < len(nodes):\n        curr = queue.pop(0)\n        if i < len(nodes) and nodes[i] != 'null':\n            curr.left = TreeNode(int(nodes[i]))\n            queue.append(curr.left)\n        i += 1\n        if i < len(nodes) and nodes[i] != 'null':\n            curr.right = TreeNode(int(nodes[i]))\n            queue.append(curr.right)\n        i += 1\n    return root\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data: return\n    # Parsing assumes standard level order inputs\n    # Note: This is a simplified parser logic for the judge context\n    pass # Implement full parsing logic based on specific test format needs\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\n\nclass TreeNode {\n    int val;\n    TreeNode left, right;\n    TreeNode(int x) { val = x; }\n}\n\npublic class Solution {\n    public static void main(String[] args) {\n        // Boilerplate for Tree building usually complex\n        // Assume standard I/O implementation provided\n    }\n}",
    "test_cases": [
      {
        "input_data": "3 5 1 6 2 0 8 null null 7 4\n5\n1",
        "expected_output": "3",
        "is_public": true
      },
      {
        "input_data": "3 5 1 6 2 0 8 null null 7 4\n5\n4",
        "expected_output": "5",
        "is_public": true
      },
      {
        "input_data": "1 2\n1\n2",
        "expected_output": "1",
        "is_public": false
      },
      {
        "input_data": "2 null 1\n2\n1",
        "expected_output": "2",
        "is_public": false
      },
      {
        "input_data": "1 2 3 4 5 6 7\n4\n5",
        "expected_output": "2",
        "is_public": false
      },
      {
        "input_data": "1 2 3 4 5 6 7\n4\n7",
        "expected_output": "1",
        "is_public": false
      }
    ]
  },
  {
    "id": 95,
    "title": "Unique Binary Search Trees II",
    "description": "Given an integer **n**, return *all the structurally unique BST's* (binary search trees), which has exactly **n** nodes of unique values from `1` to `n`.\n\nThe output should be formatted as a list of Level Order traversals.",
    "input_format": "A single integer n.",
    "output_format": "Each line contains a level-order traversal of a unique BST.",
    "difficulty": "Medium",
    "tags": [
      "dp",
      "tree",
      "bst"
    ],
    "solution": "### Observations\nTo construct a BST from 1 to n, any number `i` can be the root. If `i` is the root, then the left subtree must be built from `[1, i-1]` and the right subtree from `[i+1, n]`.\n\n### Approach\n1. **Recursive Function:** `generate(start, end)` returns a list of trees.\n2. **Base Case:** If `start > end`, return `[None]`.\n3. **Loop:** Iterate `i` from `start` to `end`.\n4. **Recursion:** Get all left subtrees `lefts = generate(start, i-1)` and right subtrees `rights = generate(i+1, end)`.\n5. **Combine:** For every combination of `l` in `lefts` and `r` in `rights`, create a root `i` connecting them.\n\n### Complexity Analysis\n* **Time:** Catalan number complexity $O(4^n / n^{1.5})$.\n* **Space:** Recursion stack.\n\n### Code Logic (Python)\n```python\ndef generate(start, end):\n    if start > end:\n        return [None]\n    all_trees = []\n    for i in range(start, end + 1):\n        left_trees = generate(start, i - 1)\n        right_trees = generate(i + 1, end)\n        for l in left_trees:\n            for r in right_trees:\n                curr = TreeNode(i)\n                curr.left = l\n                curr.right = r\n                all_trees.append(curr)\n    return all_trees\n```",
    "hints": [
      "Pick a root i from 1 to n.",
      "Recursively generate all left subtrees from 1 to i-1.",
      "Recursively generate all right subtrees from i+1 to n.",
      "Combine every left subtree with every right subtree for the chosen root."
    ],
    "boilerplate_python": "import sys\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef solve():\n    try:\n        n = int(sys.stdin.read().strip())\n    except ValueError:\n        return\n    \n    # Write logic here\n    # format output as strings\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if(sc.hasNextInt()){\n            int n = sc.nextInt();\n            // Write logic\n        }\n    }\n}",
    "test_cases": [
      {
        "input_data": "3",
        "expected_output": "[1,null,2,null,3]\n[1,null,3,2]\n[2,1,3]\n[3,1,null,null,2]\n[3,2,null,1]",
        "is_public": true
      },
      {
        "input_data": "1",
        "expected_output": "[1]",
        "is_public": true
      },
      {
        "input_data": "0",
        "expected_output": "[]",
        "is_public": false
      },
      {
        "input_data": "2",
        "expected_output": "[1,null,2]\n[2,1]",
        "is_public": false
      },
      {
        "input_data": "4",
        "expected_output": "(List of 14 trees)",
        "is_public": false
      },
      {
        "input_data": "5",
        "expected_output": "(List of 42 trees)",
        "is_public": false
      }
    ]
  },
  {
    "id": 21,
    "title": "Merge Two Sorted Lists",
    "description": "You are given the heads of two sorted linked lists **list1** and **list2**.\n\nMerge the two lists in a one **sorted** list. The list should be made by splicing together the nodes of the first two lists.\n\nReturn the head of the merged linked list.",
    "input_format": "First line: Space-separated integers for list1.\nSecond line: Space-separated integers for list2.",
    "output_format": "Space-separated integers representing the merged list.",
    "difficulty": "Easy",
    "tags": [
      "linked_list",
      "two_pointers"
    ],
    "solution": "### Observations\nSince both lists are sorted, we can iterate through both simultaneously, always picking the smaller node to append to our result.\n\n### Approach\n1. **Dummy Head:** Create a dummy node to simplify edge cases (empty lists).\n2. **Pointers:** Use a pointer `tail` to track the end of the new list.\n3. **Loop:** While both `l1` and `l2` are not null:\n   - If `l1.val < l2.val`, append `l1` to `tail.next`, move `l1`.\n   - Else, append `l2`, move `l2`.\n   - Move `tail`.\n4. **Cleanup:** Append the remaining non-null list to `tail.next`.\n\n### Complexity Analysis\n* **Time:** $O(N + M)$.\n* **Space:** $O(1)$.\n\n### Code Logic (Python)\n```python\ndummy = ListNode()\ntail = dummy\nwhile list1 and list2:\n    if list1.val < list2.val:\n        tail.next = list1\n        list1 = list1.next\n    else:\n        tail.next = list2\n        list2 = list2.next\n    tail = tail.next\ntail.next = list1 if list1 else list2\nreturn dummy.next\n```",
    "hints": [
      "Create a dummy node to act as the head of the result list.",
      "Compare the current nodes of both lists and attach the smaller one to your result.",
      "Don't forget to attach the remaining part of the non-empty list at the end."
    ],
    "boilerplate_python": "import sys\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef solve():\n    lines = sys.stdin.read().splitlines()\n    # Parsing logic needed here to convert string to Linked List\n    # Then print result list\n    pass\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode(int val) { this.val = val; }\n}\n\npublic class Solution {\n    public static void main(String[] args) {\n        // Scanner logic\n    }\n}",
    "test_cases": [
      {
        "input_data": "1 2 4\n1 3 4",
        "expected_output": "1 1 2 3 4 4",
        "is_public": true
      },
      {
        "input_data": "\n0",
        "expected_output": "0",
        "is_public": true
      },
      {
        "input_data": "\n",
        "expected_output": "",
        "is_public": false
      },
      {
        "input_data": "1\n2",
        "expected_output": "1 2",
        "is_public": false
      },
      {
        "input_data": "5 10 15\n2 3 20",
        "expected_output": "2 3 5 10 15 20",
        "is_public": false
      },
      {
        "input_data": "1 1 1\n1 1 1",
        "expected_output": "1 1 1 1 1 1",
        "is_public": false
      }
    ]
  },
  {
    "id": 78,
    "title": "Subsets",
    "description": "Given an integer array **nums** of unique elements, return all possible subsets (the power set).\n\nThe solution set must not contain duplicate subsets. Return the solution in **lexicographical order** of the subsets.",
    "input_format": "First line: N.\nSecond line: N space-separated integers.",
    "output_format": "Each line represents a subset. Elements within subsets should be sorted.",
    "difficulty": "Medium",
    "tags": [
      "searching",
      "array"
    ],
    "solution": "### Observations\nA subset can be generated by deciding for each element whether to include it or not.\n\n### Approach\n1. **Backtracking:** `backtrack(index, current_subset)`.\n2. **Base Case:** If `index == n`, add copy of `current_subset` to results.\n3. **Recursive Step:**\n   - **Exclude:** `backtrack(index + 1, current_subset)`\n   - **Include:** `current_subset.append(nums[index])`, `backtrack(index + 1, current_subset)`, `current_subset.pop()`\n\n### Complexity Analysis\n* **Time:** $O(N \\cdot 2^N)$.\n* **Space:** $O(N)$ for recursion stack.\n\n### Code Logic (Python)\n```python\nres = []\ndef backtrack(i, path):\n    if i == len(nums):\n        res.append(path[:])\n        return\n    # Include\n    path.append(nums[i])\n    backtrack(i + 1, path)\n    path.pop()\n    # Exclude\n    backtrack(i + 1, path)\n```",
    "hints": [
      "For every element, you have two choices: either include it in the current subset or not.",
      "You can also use bit manipulation (0 to 2^n - 1) to generate masks.",
      "Ensure the output is sorted if the judge requires it."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data: return\n    iterator = iter(input_data)\n    try:\n        n = int(next(iterator))\n        nums = [int(next(iterator)) for _ in range(n)]\n        nums.sort()\n    except StopIteration: return\n\n    # Write logic here\n    # Print each subset on a new line\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if(!sc.hasNext()) return;\n        int n = sc.nextInt();\n        int[] nums = new int[n];\n        for(int i=0; i<n; i++) nums[i] = sc.nextInt();\n        Arrays.sort(nums);\n        // Logic\n    }\n}",
    "test_cases": [
      {
        "input_data": "3\n1 2 3",
        "expected_output": "[]\n[1]\n[1, 2]\n[1, 2, 3]\n[1, 3]\n[2]\n[2, 3]\n[3]",
        "is_public": true
      },
      {
        "input_data": "1\n0",
        "expected_output": "[]\n[0]",
        "is_public": true
      },
      {
        "input_data": "0\n",
        "expected_output": "[]",
        "is_public": false
      },
      {
        "input_data": "2\n1 2",
        "expected_output": "[]\n[1]\n[1, 2]\n[2]",
        "is_public": false
      },
      {
        "input_data": "4\n1 2 3 4",
        "expected_output": "(16 lines)",
        "is_public": false
      },
      {
        "input_data": "2\n10 20",
        "expected_output": "[]\n[10]\n[10, 20]\n[20]",
        "is_public": false
      }
    ]
  },
  {
    "id": 39,
    "title": "Combination Sum",
    "description": "Given an array of **distinct** integers **candidates** and a target integer **target**, return a list of all unique combinations of **candidates** where the chosen numbers sum to **target**. You may return the combinations in any order.\n\nThe same number may be chosen from **candidates** an unlimited number of times.",
    "input_format": "First line: N.\nSecond line: N space-separated integers.\nThird line: Integer target.",
    "output_format": "Each line represents a combination.",
    "difficulty": "Medium",
    "tags": [
      "searching",
      "array"
    ],
    "solution": "### Observations\nSince we can reuse numbers, in our recursion, when we choose an element, we don't increment the index for the next call. When we choose *not* to use an element, we increment the index.\n\n### Approach\n1. `dfs(i, current_total, path)`\n2. **Base Cases:**\n   - `current_total == target`: Found valid combination.\n   - `current_total > target` or `i >= len`: Invalid.\n3. **Recursive Step:**\n   - **Include `nums[i]`**: `dfs(i, current_total + nums[i], path + [nums[i]])` (Stay at `i`).\n   - **Exclude `nums[i]`**: `dfs(i + 1, current_total, path)`.\n\n### Complexity Analysis\n* **Time:** Exponential $O(N^{T/M})$ where T is target, M is min value.\n* **Space:** $O(T/M)$ for path.\n\n### Code Logic (Python)\n```python\nres = []\ndef dfs(i, cur, total):\n    if total == target:\n        res.append(cur.copy())\n        return\n    if i >= len(candidates) or total > target:\n        return\n\n    cur.append(candidates[i])\n    dfs(i, cur, total + candidates[i])\n    cur.pop()\n    dfs(i + 1, cur, total)\n```",
    "hints": [
      "Since you can reuse numbers, when you include a number, recurse with the same index.",
      "If the sum exceeds the target, stop exploring that path.",
      "Sort the candidates to optimize pruning (stop early if current > target)."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data: return\n    iterator = iter(input_data)\n    try:\n        n = int(next(iterator))\n        candidates = [int(next(iterator)) for _ in range(n)]\n        target = int(next(iterator))\n    except StopIteration: return\n\n    # Write logic\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if(!sc.hasNext()) return;\n        int n = sc.nextInt();\n        int[] candidates = new int[n];\n        for(int i=0; i<n; i++) candidates[i] = sc.nextInt();\n        int target = sc.nextInt();\n        // Logic\n    }\n}",
    "test_cases": [
      {
        "input_data": "4\n2 3 6 7\n7",
        "expected_output": "[2, 2, 3]\n[7]",
        "is_public": true
      },
      {
        "input_data": "3\n2 3 5\n8",
        "expected_output": "[2, 2, 2, 2]\n[2, 3, 3]\n[3, 5]",
        "is_public": true
      },
      {
        "input_data": "1\n2\n1",
        "expected_output": "",
        "is_public": false
      },
      {
        "input_data": "1\n1\n1",
        "expected_output": "[1]",
        "is_public": false
      },
      {
        "input_data": "1\n1\n2",
        "expected_output": "[1, 1]",
        "is_public": false
      },
      {
        "input_data": "2\n3 5\n2",
        "expected_output": "",
        "is_public": false
      }
    ]
  },
  {
    "id": 46,
    "title": "Permutations",
    "description": "Given an array **nums** of distinct integers, return all the possible permutations. You can return the answer in any order (but output must be deterministic/lexicographical for the judge).",
    "input_format": "First line: N.\nSecond line: N space-separated integers.",
    "output_format": "Each line is a space-separated permutation.",
    "difficulty": "Medium",
    "tags": [
      "searching",
      "array"
    ],
    "solution": "### Observations\nWe need to arrange N distinct numbers in N positions. \n\n### Approach\n1. **Backtracking:** `backtrack(path, visited)`.\n2. **Loop:** Iterate through all numbers in `nums`.\n3. **Check:** If `nums[i]` is not in `visited`:\n   - Add to `path`, add to `visited`.\n   - Recurse.\n   - Backtrack (remove from `path`, remove from `visited`).\n4. **Base Case:** If `len(path) == len(nums)`, record permutation.\n\n### Complexity Analysis\n* **Time:** $O(N! \\cdot N)$.\n* **Space:** $O(N)$.\n\n### Code Logic (Python)\n```python\nres = []\ndef backtrack(path):\n    if len(path) == len(nums):\n        res.append(path[:])\n        return\n    for x in nums:\n        if x not in path:\n            path.append(x)\n            backtrack(path)\n            path.pop()\n```",
    "hints": [
      "Think of filling N slots one by one.",
      "Keep track of used numbers to avoid duplicates in the same permutation.",
      "The total number of results is N!."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data: return\n    iterator = iter(input_data)\n    try:\n        n = int(next(iterator))\n        nums = [int(next(iterator)) for _ in range(n)]\n        nums.sort()\n    except StopIteration: return\n    \n    # Logic\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if(!sc.hasNext()) return;\n        int n = sc.nextInt();\n        int[] nums = new int[n];\n        for(int i=0; i<n; i++) nums[i] = sc.nextInt();\n        Arrays.sort(nums);\n        // Logic\n    }\n}",
    "test_cases": [
      {
        "input_data": "3\n1 2 3",
        "expected_output": "1 2 3\n1 3 2\n2 1 3\n2 3 1\n3 1 2\n3 2 1",
        "is_public": true
      },
      {
        "input_data": "2\n0 1",
        "expected_output": "0 1\n1 0",
        "is_public": true
      },
      {
        "input_data": "1\n1",
        "expected_output": "1",
        "is_public": false
      },
      {
        "input_data": "2\n1 2",
        "expected_output": "1 2\n2 1",
        "is_public": false
      },
      {
        "input_data": "3\n3 2 1",
        "expected_output": "(6 lines, sorted)",
        "is_public": false
      },
      {
        "input_data": "4\n1 2 3 4",
        "expected_output": "(24 lines)",
        "is_public": false
      }
    ]
  },
  {
    "id": 79,
    "title": "Word Search",
    "description": "Given an $m \\times n$ grid of characters **board** and a string **word**, return `true` if **word** exists in the grid.\n\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.",
    "input_format": "First line: R C (rows, cols).\nNext R lines: C space-separated chars.\nLast line: String word.",
    "output_format": "true or false",
    "difficulty": "Medium",
    "tags": [
      "array",
      "searching"
    ],
    "solution": "### Observations\nWe need to explore the grid to match the sequence of characters in `word`.\n\n### Approach\n1. Iterate through every cell `(r, c)` in the grid.\n2. If `board[r][c]` matches `word[0]`, start DFS.\n3. **DFS(r, c, index):**\n   - If `index == len(word)`, return True.\n   - Mark `(r, c)` as visited (e.g., replace char with '#').\n   - Check all 4 directions. If neighbor matches `word[index+1]`, recurse.\n   - Backtrack: Restore `board[r][c]`.\n\n### Complexity Analysis\n* **Time:** $O(N \\cdot 3^L)$ where N is cells, L is word length.\n* **Space:** $O(L)$ for recursion.\n\n### Code Logic (Python)\n```python\ndef dfs(r, c, i):\n    if i == len(word):\n        return True\n    if r < 0 or c < 0 or r >= R or c >= C or board[r][c] != word[i]:\n        return False\n    \n    temp, board[r][c] = board[r][c], '#'\n    res = (dfs(r+1, c, i+1) or dfs(r-1, c, i+1) or \n           dfs(r, c+1, i+1) or dfs(r, c-1, i+1))\n    board[r][c] = temp\n    return res\n```",
    "hints": [
      "Start a DFS from every cell that matches the first letter.",
      "Mark visited cells to avoid cycles.",
      "Don't forget to unmark (backtrack) after returning from recursion."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data: return\n    iterator = iter(input_data)\n    try:\n        R = int(next(iterator))\n        C = int(next(iterator))\n        board = []\n        for _ in range(R):\n            row = [next(iterator) for _ in range(C)]\n            board.append(row)\n        word = next(iterator)\n    except StopIteration: return\n    \n    # Logic\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if(!sc.hasNext()) return;\n        int R = sc.nextInt();\n        int C = sc.nextInt();\n        char[][] board = new char[R][C];\n        for(int i=0; i<R; i++){\n            for(int j=0; j<C; j++){\n                board[i][j] = sc.next().charAt(0);\n            }\n        }\n        String word = sc.next();\n        // Logic\n    }\n}",
    "test_cases": [
      {
        "input_data": "3 4\nA B C E\nS F C S\nA D E E\nABCCED",
        "expected_output": "true",
        "is_public": true
      },
      {
        "input_data": "3 4\nA B C E\nS F C S\nA D E E\nSEE",
        "expected_output": "true",
        "is_public": true
      },
      {
        "input_data": "3 4\nA B C E\nS F C S\nA D E E\nABCB",
        "expected_output": "false",
        "is_public": true
      },
      {
        "input_data": "1 1\nA\nA",
        "expected_output": "true",
        "is_public": false
      },
      {
        "input_data": "1 1\nA\nB",
        "expected_output": "false",
        "is_public": false
      },
      {
        "input_data": "2 2\nA B\nC D\nACDB",
        "expected_output": "false",
        "is_public": false
      }
    ]
  },
  {
    "id": 51,
    "title": "N-Queens",
    "description": "The **n-queens** puzzle is the problem of placing `n` queens on an $n \\times n$ chessboard such that no two queens attack each other.\n\nGiven an integer **n**, return all distinct solutions to the **n-queens puzzle**. You may return the answer in any order.",
    "input_format": "Integer n.",
    "output_format": "Print each solution board separated by a newline.",
    "difficulty": "Hard",
    "tags": [
      "searching"
    ],
    "solution": "### Observations\nWe need to place one Queen per row such that no two Queens share a column or diagonal.\n\n### Approach\n1. **State:** `cols`, `diag1` (r+c), `diag2` (r-c) sets to track attacks.\n2. **Backtrack(row):**\n   - If `row == n`, we found a solution.\n   - Iterate `col` from 0 to `n-1`.\n   - If `col` not in `cols` and diagonals safe:\n     - Place Queen.\n     - Update sets.\n     - Recurse `row + 1`.\n     - Backtrack (remove Queen, revert sets).\n\n### Complexity Analysis\n* **Time:** $O(N!)$.\n* **Space:** $O(N)$.\n\n### Code Logic (Python)\n```python\ncols = set()\nposDiag = set() # (r + c)\nnegDiag = set() # (r - c)\n\ndef backtrack(r):\n    if r == n:\n        # format board\n        return\n    for c in range(n):\n        if c in cols or (r + c) in posDiag or (r - c) in negDiag:\n            continue\n        \n        cols.add(c)\n        posDiag.add(r + c)\n        negDiag.add(r - c)\n        board[r][c] = \"Q\"\n        \n        backtrack(r + 1)\n        \n        cols.remove(c)\n        posDiag.remove(r + c)\n        negDiag.remove(r - c)\n        board[r][c] = \".\"\n```",
    "hints": [
      "Place queens row by row.",
      "Maintain sets to quickly check if a column or diagonal is occupied.",
      "The sum (row + col) is constant for one diagonal, (row - col) is constant for the anti-diagonal."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    try:\n        n = int(sys.stdin.read().strip())\n    except: return\n    \n    # Logic\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if(!sc.hasNext()) return;\n        int n = sc.nextInt();\n        // Logic\n    }\n}",
    "test_cases": [
      {
        "input_data": "4",
        "expected_output": ".Q..\n...Q\nQ...\n..Q.\n\n..Q.\nQ...\n...Q\n.Q..",
        "is_public": true
      },
      {
        "input_data": "1",
        "expected_output": "Q",
        "is_public": true
      },
      {
        "input_data": "2",
        "expected_output": "",
        "is_public": false
      },
      {
        "input_data": "3",
        "expected_output": "",
        "is_public": false
      },
      {
        "input_data": "5",
        "expected_output": "(10 solutions)",
        "is_public": false
      },
      {
        "input_data": "6",
        "expected_output": "(4 solutions)",
        "is_public": false
      }
    ]
  }
]