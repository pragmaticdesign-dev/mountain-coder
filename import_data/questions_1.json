[
  {
    "id": 238,
    "title": "Product of Array Except Self",
    "description": "Given an integer array **nums**, return an array **answer** such that **answer[i]** is equal to the product of all the elements of **nums** except **nums[i]**.\n\nThe product of any prefix or suffix of **nums** is guaranteed to fit in a **32-bit** integer.\n\nYou must write an algorithm that runs in **O(n)** time and without using the division operation.",
    "input_format": "First line: An integer N (length of array).\nSecond line: N space-separated integers representing nums.",
    "output_format": "Print the result array elements separated by space.",
    "difficulty": "Medium",
    "tags": [
      "array"
    ],
    "solution": "### Observations\nWe cannot use division. This means for index `i`, we need `prefix_product[i-1] * suffix_product[i+1]`.\n\n### Approach\n1. **Two Pass Approach**: Create two arrays, `left` and `right`. `left[i]` stores product of all elements before `i`. `right[i]` stores product of all elements after `i`.\n2. **Optimization**: We can save space by using the output array to store the `left` products, and then calculating `right` products on the fly while traversing backward.\n\n### Complexity Analysis\n- **Time:** O(N) - Two passes.\n- **Space:** O(1) - Excluding output array.\n\n### Code Logic\n```python\ndef solve(nums):\n    n = len(nums)\n    res = [1] * n\n    prefix = 1\n    for i in range(n):\n        res[i] = prefix\n        prefix *= nums[i]\n    postfix = 1\n    for i in range(n - 1, -1, -1):\n        res[i] *= postfix\n        postfix *= nums[i]\n    return res\n```",
    "hints": [
      "Think about calculating the product of elements to the left of index i.",
      "Think about calculating the product of elements to the right of index i.",
      "Combine the left and right products to get the result.",
      "Can you do this using the output array as temporary storage to save space?"
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    # Input reading\n    try:\n        input = sys.stdin.read().split()\n        if not input: return\n        n = int(input[0])\n        nums = [int(x) for x in input[1:]]\n        \n        # Logic here\n        result = [1] * n\n        prefix = 1\n        for i in range(n):\n            result[i] = prefix\n            prefix *= nums[i]\n        postfix = 1\n        for i in range(n - 1, -1, -1):\n            result[i] *= postfix\n            postfix *= nums[i]\n            \n        print(*(result))\n    except Exception as e:\n        return\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if(sc.hasNextInt()) {\n            int n = sc.nextInt();\n            int[] nums = new int[n];\n            for(int i=0; i<n; i++) nums[i] = sc.nextInt();\n            \n            // Implement logic here\n            // For boilerplate purposes, printing dummy output\n            // System.out.println(Arrays.toString(nums));\n        }\n    }\n}",
    "test_cases": [
      {
        "input_data": "4\n1 2 3 4",
        "expected_output": "24 12 8 6",
        "is_public": true
      },
      {
        "input_data": "5\n-1 1 0 -3 3",
        "expected_output": "0 0 9 0 0",
        "is_public": true
      },
      {
        "input_data": "2\n0 0",
        "expected_output": "0 0",
        "is_public": false
      },
      {
        "input_data": "3\n1 1 1",
        "expected_output": "1 1 1",
        "is_public": false
      },
      {
        "input_data": "5\n1 2 3 4 0",
        "expected_output": "0 0 0 0 24",
        "is_public": false
      },
      {
        "input_data": "2\n10 20",
        "expected_output": "20 10",
        "is_public": false
      }
    ]
  },
  {
    "id": 128,
    "title": "Longest Consecutive Sequence",
    "description": "Given an unsorted array of integers **nums**, return the length of the longest consecutive elements sequence.\n\nYou must write an algorithm that runs in **O(n)** time.",
    "input_format": "First line: An integer N (length of array).\nSecond line: N space-separated integers.",
    "output_format": "Print a single integer representing the length of the longest consecutive sequence.",
    "difficulty": "Medium",
    "tags": [
      "array",
      "set",
      "map"
    ],
    "solution": "### Observations\nSorting takes O(N log N), which violates the constraint. We need O(N). Hash Sets allow O(1) lookups.\n\n### Approach\n1. Add all numbers to a `HashSet`.\n2. Iterate through the set. For a number `x`, check if `x-1` exists.\n3. If `x-1` exists, `x` is not the start of a sequence. Skip it.\n4. If `x-1` does not exist, `x` is the start. Check for `x+1`, `x+2`, etc., in the set and count the length.\n5. Track the maximum length.\n\n### Complexity Analysis\n- **Time:** O(N) - We iterate through the array once to build the set, and then iterate the set. The inner while loop runs only for sequence starters and visits each number exactly once globally.\n- **Space:** O(N) - To store the set.\n\n### Code Logic\n```python\ndef solve(nums):\n    num_set = set(nums)\n    longest = 0\n    for n in num_set:\n        if (n - 1) not in num_set:\n            length = 0\n            while (n + length) in num_set:\n                length += 1\n            longest = max(longest, length)\n    return longest\n```",
    "hints": [
      "Can you use a Set to allow O(1) lookups?",
      "To verify if a number is the start of a sequence, check if (num - 1) exists in the set.",
      "Only start counting the sequence length if the current number is the start of a sequence."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    try:\n        input_data = sys.stdin.read().split()\n        if not input_data: return\n        n = int(input_data[0])\n        nums = [int(x) for x in input_data[1:]]\n        \n        # Logic implementation needed here\n        pass\n        \n    except Exception:\n        return\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if(sc.hasNextInt()) {\n            int n = sc.nextInt();\n            // Logic here\n        }\n    }\n}",
    "test_cases": [
      {
        "input_data": "6\n100 4 200 1 3 2",
        "expected_output": "4",
        "is_public": true
      },
      {
        "input_data": "10\n0 3 7 2 5 8 4 6 0 1",
        "expected_output": "9",
        "is_public": true
      },
      {
        "input_data": "0\n",
        "expected_output": "0",
        "is_public": false
      },
      {
        "input_data": "1\n10",
        "expected_output": "1",
        "is_public": false
      },
      {
        "input_data": "5\n1 2 0 1 2",
        "expected_output": "3",
        "is_public": false
      },
      {
        "input_data": "5\n10 20 30 40 50",
        "expected_output": "1",
        "is_public": false
      }
    ]
  },
  {
    "id": 560,
    "title": "Subarray Sum Equals K",
    "description": "Given an array of integers **nums** and an integer **k**, return the total number of continuous subarrays whose sum equals to **k**.",
    "input_format": "First line: N (array size) and K (target sum).\nSecond line: N space-separated integers.",
    "output_format": "Print the count of subarrays.",
    "difficulty": "Medium",
    "tags": [
      "array",
      "map"
    ],
    "solution": "### Observations\nBrute force checking all subarrays is O(N^2). We can use Prefix Sums. If `prefix_sum[j] - prefix_sum[i] == k`, then subarray `i+1...j` sums to k.\n\n### Approach\n1. Maintain a variable `current_sum` and a Hash Map `prefix_counts` that stores `{sum: count}`.\n2. Initialize map with `{0: 1}` (to handle subarrays starting from index 0).\n3. Iterate through `nums`:\n   - Add current number to `current_sum`.\n   - Check if `current_sum - k` exists in the map.\n   - If yes, add `prefix_counts[current_sum - k]` to result.\n   - Update map with `current_sum`.\n\n### Complexity Analysis\n- **Time:** O(N)\n- **Space:** O(N) for the map.\n\n### Code Logic\n```python\ndef solve(nums, k):\n    count = 0\n    s = 0\n    d = {0: 1}\n    for i in nums:\n        s += i\n        if s - k in d:\n            count += d[s - k]\n        d[s] = d.get(s, 0) + 1\n    return count\n```",
    "hints": [
      "Calculate the prefix sum as you iterate.",
      "If (current_prefix_sum - k) has been seen before, it means there is a subarray ending here with sum k.",
      "Use a hash map to store frequencies of prefix sums."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data: return\n    n = int(input_data[0])\n    k = int(input_data[1])\n    nums = [int(x) for x in input_data[2:]]\n    \n    # Implement logic\n    pass\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        // Logic\n    }\n}",
    "test_cases": [
      {
        "input_data": "3 2\n1 1 1",
        "expected_output": "2",
        "is_public": true
      },
      {
        "input_data": "3 3\n1 2 3",
        "expected_output": "2",
        "is_public": true
      },
      {
        "input_data": "1 0\n0",
        "expected_output": "1",
        "is_public": false
      },
      {
        "input_data": "1 5\n10",
        "expected_output": "0",
        "is_public": false
      },
      {
        "input_data": "4 0\n1 -1 1 -1",
        "expected_output": "4",
        "is_public": false
      },
      {
        "input_data": "5 10\n2 3 5 2 8",
        "expected_output": "2",
        "is_public": false
      }
    ]
  },
  {
    "id": 41,
    "title": "First Missing Positive",
    "description": "Given an unsorted integer array **nums**, return the smallest missing positive integer.\n\nYou must implement an algorithm that runs in **O(n)** time and uses **O(1)** auxiliary space.",
    "input_format": "First line: N\nSecond line: N integers",
    "output_format": "Print the smallest missing positive integer.",
    "difficulty": "Hard",
    "tags": [
      "array"
    ],
    "solution": "### Observations\nWe need to find the smallest missing positive. The answer must be in the range `[1, N+1]`.\n\n### Approach\n1. **Cyclic Sort**: We place every number `x` in the range `[1, N]` at index `x-1`. \n2. Iterate through the array. While `nums[i]` is between 1 and N and `nums[nums[i]-1] != nums[i]`, swap `nums[i]` with `nums[nums[i]-1]`.\n3. After sorting, iterate through the array. The first index `i` where `nums[i] != i+1` is the missing number `i+1`.\n4. If all indices match, the missing number is `N+1`.\n\n### Complexity Analysis\n- **Time:** O(N)\n- **Space:** O(1)\n\n### Code Logic\n```python\ndef solve(nums):\n    n = len(nums)\n    for i in range(n):\n        while 1 <= nums[i] <= n and nums[nums[i]-1] != nums[i]:\n            correct_idx = nums[i] - 1\n            nums[i], nums[correct_idx] = nums[correct_idx], nums[i]\n    \n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n    return n + 1\n```",
    "hints": [
      "The answer must be between 1 and N+1.",
      "Can you place the integer 1 at index 0, 2 at index 1, etc.?",
      "Ignore negative numbers and numbers larger than N."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data: return\n    n = int(input_data[0])\n    nums = [int(x) for x in input_data[1:]]\n    \n    # Logic\n    pass\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        // Logic\n    }\n}",
    "test_cases": [
      {
        "input_data": "3\n1 2 0",
        "expected_output": "3",
        "is_public": true
      },
      {
        "input_data": "4\n3 4 -1 1",
        "expected_output": "2",
        "is_public": true
      },
      {
        "input_data": "5\n7 8 9 11 12",
        "expected_output": "1",
        "is_public": true
      },
      {
        "input_data": "3\n1 2 3",
        "expected_output": "4",
        "is_public": false
      },
      {
        "input_data": "1\n100",
        "expected_output": "1",
        "is_public": false
      },
      {
        "input_data": "6\n1 1 1 1 2 3",
        "expected_output": "4",
        "is_public": false
      }
    ]
  },
  {
    "id": 380,
    "title": "Insert Delete GetRandom O(1)",
    "description": "Implement the **RandomizedSet** class:\n\n* `bool insert(int val)` Inserts an item `val` into the set if not present. Returns true if the item was not present, false otherwise.\n* `bool remove(int val)` Removes an item `val` from the set if present. Returns true if the item was present, false otherwise.\n* `int getRandom()` Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the **same probability** of being returned.\n\nYou must implement the functions of the class such that each function works in **average** `O(1)` time complexity.",
    "input_format": "First line: Q (number of operations).\nNext Q lines: String (command) followed by optional integer.",
    "output_format": "Print result of each operation on a new line.",
    "difficulty": "Medium",
    "tags": [
      "array",
      "map"
    ],
    "solution": "### Observations\nHash Maps allow O(1) insert/delete but not random access. Arrays allow random access and O(1) insert (at end), but O(N) delete (shifting).\n\n### Approach\n1. Use **both** a list and a map.\n2. `Map`: Stores `{value: index_in_list}`.\n3. `List`: Stores values.\n4. **Insert**: Append to list, update map. O(1).\n5. **Remove**: This is the trick. Swap the element to remove with the *last* element in the list. Update the map for the swapped element. Pop the last element. O(1).\n6. **GetRandom**: `random.choice(list)`. O(1).\n\n### Complexity Analysis\n- **Time:** O(1) average for all ops.\n- **Space:** O(N).\n\n### Code Logic\n```python\nclass RandomizedSet:\n    def __init__(self):\n        self.nums = []\n        self.pos = {}\n\n    def insert(self, val):\n        if val in self.pos:\n            return \"false\"\n        self.nums.append(val)\n        self.pos[val] = len(self.nums) - 1\n        return \"true\"\n\n    def remove(self, val):\n        if val not in self.pos:\n            return \"false\"\n        idx = self.pos[val]\n        last = self.nums[-1]\n        self.nums[idx] = last\n        self.pos[last] = idx\n        self.nums.pop()\n        del self.pos[val]\n        return \"true\"\n\n    def getRandom(self):\n        import random\n        return random.choice(self.nums)\n```",
    "hints": [
      "Use an ArrayList (dynamic array) to store numbers for O(1) random access.",
      "Use a HashMap to store the index of each number in the ArrayList for O(1) lookup.",
      "To delete in O(1), swap the target element with the last element in the list, then remove the last element."
    ],
    "boilerplate_python": "import sys\nimport random\n\nclass RandomizedSet:\n    def __init__(self):\n        self.d = {}\n        self.v = []\n\n    def insert(self, val):\n        if val in self.d:\n            return \"false\"\n        self.v.append(val)\n        self.d[val] = len(self.v) - 1\n        return \"true\"\n\n    def remove(self, val):\n        if val not in self.d:\n            return \"false\"\n        idx = self.d[val]\n        last = self.v[-1]\n        self.v[idx] = last\n        self.d[last] = idx\n        self.v.pop()\n        del self.d[val]\n        return \"true\"\n\n    def getRandom(self):\n        return random.choice(self.v)\n\ndef solve():\n    lines = sys.stdin.read().split()\n    if not lines: return\n    q = int(lines[0])\n    idx = 1\n    obj = RandomizedSet()\n    \n    for _ in range(q):\n        cmd = lines[idx]\n        idx += 1\n        if cmd == \"insert\":\n            val = int(lines[idx])\n            idx += 1\n            print(obj.insert(val))\n        elif cmd == \"remove\":\n            val = int(lines[idx])\n            idx += 1\n            print(obj.remove(val))\n        elif cmd == \"getRandom\":\n            # For judging purposes, checking specific logic is hard with randomness.\n            # We just print the random value.\n            print(obj.getRandom())\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int q = sc.nextInt();\n        RandomizedSet obj = new RandomizedSet();\n        while(q-- > 0) {\n            String cmd = sc.next();\n            if(cmd.equals(\"insert\")) System.out.println(obj.insert(sc.nextInt()));\n            else if(cmd.equals(\"remove\")) System.out.println(obj.remove(sc.nextInt()));\n            else System.out.println(obj.getRandom());\n        }\n    }\n}\nclass RandomizedSet {\n    // Implement here\n    public RandomizedSet() {}\n    public boolean insert(int val) { return false; }\n    public boolean remove(int val) { return false; }\n    public int getRandom() { return 0; }\n}",
    "test_cases": [
      {
        "input_data": "4\ninsert 1\nremove 2\ninsert 2\nremove 1",
        "expected_output": "true\nfalse\ntrue\ntrue",
        "is_public": true
      },
      {
        "input_data": "3\ninsert 1\ninsert 1\nremove 1",
        "expected_output": "true\nfalse\ntrue",
        "is_public": true
      },
      {
        "input_data": "1\ninsert 10",
        "expected_output": "true",
        "is_public": false
      },
      {
        "input_data": "1\nremove 10",
        "expected_output": "false",
        "is_public": false
      },
      {
        "input_data": "5\ninsert 1\ninsert 2\nremove 1\ninsert 1\nremove 2",
        "expected_output": "true\ntrue\ntrue\ntrue\ntrue",
        "is_public": false
      },
      {
        "input_data": "3\ninsert -1\ninsert -2\nremove -1",
        "expected_output": "true\ntrue\ntrue",
        "is_public": false
      }
    ]
  },
  {
    "id": 31,
    "title": "Next Permutation",
    "description": "A **permutation** of an array of integers is an arrangement of its members into a sequence or linear order.\n\nThe **next permutation** of an array of integers is the next lexicographically greater permutation of its integer. If such an arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\nThe replacement must be **in place** and use only constant extra memory.",
    "input_format": "First line: N\nSecond line: N integers",
    "output_format": "Print the elements of the next permutation.",
    "difficulty": "Medium",
    "tags": [
      "array",
      "two_pointers"
    ],
    "solution": "### Observations\nTo find the next greater number, we need to swap a smaller number with a slightly larger one as far right as possible.\n\n### Approach\n1. Find the first decreasing element from the end (pivot). Index `i` such that `nums[i] < nums[i+1]`.\n2. If no such element exists (array is descending), reverse the whole array.\n3. If found, search from the end for the first number greater than `nums[i]`. Swap them.\n4. Reverse the suffix starting from `i+1`.\n\n### Complexity Analysis\n- **Time:** O(N)\n- **Space:** O(1)\n\n### Code Logic\n```python\ndef solve(nums):\n    i = len(nums) - 2\n    while i >= 0 and nums[i] >= nums[i + 1]:\n        i -= 1\n    if i >= 0:\n        j = len(nums) - 1\n        while nums[j] <= nums[i]:\n            j -= 1\n        nums[i], nums[j] = nums[j], nums[i]\n    nums[i + 1:] = reversed(nums[i + 1:])\n    return nums\n```",
    "hints": [
      "Find the first pair of adjacent elements from the right where nums[i] < nums[i+1].",
      "If such a pair exists, find the smallest number to the right of 'i' that is greater than nums[i].",
      "Swap them and reverse the part of the array to the right of 'i'."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data: return\n    n = int(input_data[0])\n    nums = [int(x) for x in input_data[1:]]\n    \n    # Logic\n    i = n - 2\n    while i >= 0 and nums[i] >= nums[i + 1]:\n        i -= 1\n    if i >= 0:\n        j = n - 1\n        while nums[j] <= nums[i]:\n            j -= 1\n        nums[i], nums[j] = nums[j], nums[i]\n    \n    # Reverse logic manual for in-place without slice assignment issues in some envs\n    l, r = i + 1, n - 1\n    while l < r:\n        nums[l], nums[r] = nums[r], nums[l]\n        l += 1\n        r -= 1\n        \n    print(*(nums))\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] nums = new int[n];\n        for(int i=0; i<n; i++) nums[i] = sc.nextInt();\n        // Logic\n    }\n}",
    "test_cases": [
      {
        "input_data": "3\n1 2 3",
        "expected_output": "1 3 2",
        "is_public": true
      },
      {
        "input_data": "3\n3 2 1",
        "expected_output": "1 2 3",
        "is_public": true
      },
      {
        "input_data": "3\n1 1 5",
        "expected_output": "1 5 1",
        "is_public": true
      },
      {
        "input_data": "1\n1",
        "expected_output": "1",
        "is_public": false
      },
      {
        "input_data": "2\n1 1",
        "expected_output": "1 1",
        "is_public": false
      },
      {
        "input_data": "4\n1 3 2 1",
        "expected_output": "2 1 1 3",
        "is_public": false
      }
    ]
  }
]