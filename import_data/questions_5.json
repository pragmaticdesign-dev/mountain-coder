[
  {
    "id": 34,
    "title": "Find First and Last Position of Element in Sorted Array",
    "description": "Given an array of integers **nums** sorted in non-decreasing order, find the starting and ending position of a given **target** value.\n\nIf **target** is not found in the array, return `[-1, -1]`.\n\nYou must write an algorithm with $O(\\log n)$ runtime complexity.",
    "input_format": "First line: An integer N (size of the array).\nSecond line: N space-separated integers representing the array nums.\nThird line: An integer target.",
    "output_format": "Two space-separated integers representing the first and last position.",
    "difficulty": "Medium",
    "tags": [
      "array",
      "binary_search"
    ],
    "solution": "### Observations\nSince the array is sorted, we can use **Binary Search**. However, a standard binary search only finds *one* instance. We need to find the boundaries.\n\n### Approach\n1. **Find First Occurrence:** Use binary search. When `nums[mid] == target`, don't stop. Record the index and continue searching in the *left* half (`high = mid - 1`) to see if there is an earlier occurrence.\n2. **Find Last Occurrence:** Use binary search. When `nums[mid] == target`, record the index and search in the *right* half (`low = mid + 1`) to see if there is a later occurrence.\n\n### Complexity Analysis\n* **Time:** $O(\\log n)$ because we perform two binary searches.\n* **Space:** $O(1)$ auxiliary space.\n\n### Code Logic (Python)\n```python\ndef binary_search(nums, target, find_first):\n    l, r = 0, len(nums) - 1\n    ans = -1\n    while l <= r:\n        mid = (l + r) // 2\n        if nums[mid] == target:\n            ans = mid\n            if find_first:\n                r = mid - 1\n            else:\n                l = mid + 1\n        elif nums[mid] < target:\n            l = mid + 1\n        else:\n            r = mid - 1\n    return ans\n```",
    "hints": [
      "Standard binary search finds any index of the target. How can you modify it to find the leftmost index?",
      "If nums[mid] == target, finding the first position requires checking the left subarray.",
      "If nums[mid] == target, finding the last position requires checking the right subarray.",
      "You can implement two separate binary search functions or one function with a boolean flag."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    \n    iterator = iter(input_data)\n    try:\n        n = int(next(iterator))\n        nums = [int(next(iterator)) for _ in range(n)]\n        target = int(next(iterator))\n    except StopIteration:\n        return\n\n    # Write your solution here\n    # Print output as: print(f\"{first} {last}\")\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        if (!scanner.hasNextInt()) return;\n        \n        int n = scanner.nextInt();\n        int[] nums = new int[n];\n        for (int i = 0; i < n; i++) {\n            nums[i] = scanner.nextInt();\n        }\n        int target = scanner.nextInt();\n        \n        // Write your solution here\n        // System.out.println(first + \" \" + last);\n    }\n}",
    "test_cases": [
      {
        "input_data": "6\n5 7 7 8 8 10\n8",
        "expected_output": "3 4",
        "is_public": true
      },
      {
        "input_data": "6\n5 7 7 8 8 10\n6",
        "expected_output": "-1 -1",
        "is_public": true
      },
      {
        "input_data": "0\n\n0",
        "expected_output": "-1 -1",
        "is_public": false
      },
      {
        "input_data": "1\n1\n1",
        "expected_output": "0 0",
        "is_public": false
      },
      {
        "input_data": "5\n2 2 2 2 2\n2",
        "expected_output": "0 4",
        "is_public": false
      },
      {
        "input_data": "5\n2 2 2 2 2\n3",
        "expected_output": "-1 -1",
        "is_public": false
      }
    ]
  },
  {
    "id": 74,
    "title": "Search a 2D Matrix",
    "description": "Write an efficient algorithm that searches for a value **target** in an $m \\times n$ integer matrix **matrix**. This matrix has the following properties:\n\n* Integers in each row are sorted from left to right.\n* The first integer of each row is greater than the last integer of the previous row.",
    "input_format": "First line: Two integers R and C (Rows and Columns).\nNext R lines: C space-separated integers per line.\nLast line: Integer target.",
    "output_format": "Print \"true\" if the target is found, otherwise \"false\".",
    "difficulty": "Medium",
    "tags": [
      "array",
      "binary_search"
    ],
    "solution": "### Observations\nThe matrix properties imply that if we flatten the matrix, it forms a strictly sorted 1D array. \n\n### Approach\nInstead of creating a 1D array (which takes space), we can treat the matrix as a virtual sorted array of size $R \\times C$.\n1. **Virtual Indexing:** An index `mid` in range $[0, R \\times C - 1]$ maps to `matrix[mid // C][mid % C]`.\n2. **Binary Search:** Perform standard binary search on the range $[0, R \\times C - 1]$.\n\n### Complexity Analysis\n* **Time:** $O(\\log(R \\times C))$, which is standard binary search.\n* **Space:** $O(1)$.\n\n### Code Logic (Java)\n```java\nint low = 0;\nint high = R * C - 1;\nwhile (low <= high) {\n    int mid = low + (high - low) / 2;\n    int midVal = matrix[mid / C][mid % C];\n    if (midVal == target) return true;\n    else if (midVal < target) low = mid + 1;\n    else high = mid - 1;\n}\nreturn false;\n```",
    "hints": [
      "Treat the 2D matrix as a single sorted 1D array.",
      "The total number of elements is rows * cols.",
      "How can you convert a 1D index back to row and column coordinates? Think division and modulo."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    iterator = iter(input_data)\n    try:\n        R = int(next(iterator))\n        C = int(next(iterator))\n        matrix = []\n        for _ in range(R):\n            row = [int(next(iterator)) for _ in range(C)]\n            matrix.append(row)\n        target = int(next(iterator))\n    except StopIteration:\n        return\n\n    # Write logic here\n    # print(\"true\" or \"false\")\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if(!sc.hasNext()) return;\n        int R = sc.nextInt();\n        int C = sc.nextInt();\n        int[][] matrix = new int[R][C];\n        for(int i=0; i<R; i++) {\n            for(int j=0; j<C; j++) {\n                matrix[i][j] = sc.nextInt();\n            }\n        }\n        int target = sc.nextInt();\n        // Write logic here\n        // System.out.println(\"true\" or \"false\");\n    }\n}",
    "test_cases": [
      {
        "input_data": "3 4\n1 3 5 7\n10 11 16 20\n23 30 34 60\n3",
        "expected_output": "true",
        "is_public": true
      },
      {
        "input_data": "3 4\n1 3 5 7\n10 11 16 20\n23 30 34 60\n13",
        "expected_output": "false",
        "is_public": true
      },
      {
        "input_data": "1 1\n10\n10",
        "expected_output": "true",
        "is_public": false
      },
      {
        "input_data": "1 1\n10\n5",
        "expected_output": "false",
        "is_public": false
      },
      {
        "input_data": "2 2\n1 2\n3 4\n4",
        "expected_output": "true",
        "is_public": false
      },
      {
        "input_data": "2 2\n1 2\n3 4\n0",
        "expected_output": "false",
        "is_public": false
      }
    ]
  },
  {
    "id": 162,
    "title": "Find Peak Element",
    "description": "A peak element is an element that is strictly greater than its neighbors.\nGiven a **0-indexed** integer array **nums**, find a peak element, and return its index. If the array contains multiple peaks, return the index to **any of the peaks**.\n\nYou may imagine that `nums[-1] = nums[n] = -∞`.\n\nYou must write an algorithm that runs in $O(\\log n)$ time.",
    "input_format": "First line: Integer N.\nSecond line: N space-separated integers.",
    "output_format": "An integer representing the index of the peak element.",
    "difficulty": "Medium",
    "tags": [
      "array",
      "binary_search"
    ],
    "solution": "### Observations\nThe constraints say $O(\\log n)$, implying Binary Search. Since the array isn't sorted, how does BS work? If we are on an ascending slope, a peak must exist to the right. If we are on a descending slope, a peak must exist to the left.\n\n### Approach\n1. Initialize `l = 0`, `r = n - 1`.\n2. Calculate `mid`.\n3. Compare `nums[mid]` with `nums[mid + 1]`.\n    * If `nums[mid] < nums[mid + 1]`: We are on an upward slope. The peak is to the right. `l = mid + 1`.\n    * If `nums[mid] > nums[mid + 1]`: We are on a downward slope (or a local peak). The peak is at `mid` or to the left. `r = mid`.\n4. **Loop Termination:** When `l == r`, we found a peak.\n\n### Complexity Analysis\n* **Time:** $O(\\log n)$.\n* **Space:** $O(1)$.\n\n### Code Logic (Python)\n```python\nwhile l < r:\n    mid = (l + r) // 2\n    if nums[mid] > nums[mid + 1]:\n        # We are falling, so peak is mid or left\n        r = mid\n    else:\n        # We are rising, so peak is strictly right\n        l = mid + 1\nreturn l\n```",
    "hints": [
      "Think of the array as a mountain range.",
      "If nums[i] < nums[i+1], then we are climbing up. Where must the peak be?",
      "If nums[i] > nums[i+1], we are going down. Where is the peak relative to i?",
      "You don't need to check both neighbors, checking the right neighbor is sufficient to determine slope."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    iterator = iter(input_data)\n    try:\n        n = int(next(iterator))\n        nums = [int(next(iterator)) for _ in range(n)]\n    except StopIteration:\n        return\n\n    # Write logic here\n    # print(index)\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if(!sc.hasNext()) return;\n        int n = sc.nextInt();\n        int[] nums = new int[n];\n        for(int i=0; i<n; i++) nums[i] = sc.nextInt();\n        \n        // Write logic here\n        // System.out.println(index);\n    }\n}",
    "test_cases": [
      {
        "input_data": "4\n1 2 3 1",
        "expected_output": "2",
        "is_public": true
      },
      {
        "input_data": "7\n1 2 1 3 5 6 4",
        "expected_output": "5",
        "is_public": true
      },
      {
        "input_data": "1\n10",
        "expected_output": "0",
        "is_public": false
      },
      {
        "input_data": "2\n1 2",
        "expected_output": "1",
        "is_public": false
      },
      {
        "input_data": "2\n2 1",
        "expected_output": "0",
        "is_public": false
      },
      {
        "input_data": "5\n1 2 3 4 5",
        "expected_output": "4",
        "is_public": false
      }
    ]
  },
  {
    "id": 153,
    "title": "Find Minimum in Rotated Sorted Array",
    "description": "Suppose an array of length `n` sorted in ascending order is rotated between `1` and `n` times. For example, the array `nums = [0,1,2,4,5,6,7]` might become:\n* `[4,5,6,7,0,1,2]` if it was rotated 4 times.\n\nGiven the sorted rotated array **nums** of unique elements, return the *minimum element* of this array.\n\nYou must write an algorithm that runs in $O(\\log n)$ time.",
    "input_format": "First line: Integer N.\nSecond line: N space-separated integers.",
    "output_format": "Print the minimum integer.",
    "difficulty": "Medium",
    "tags": [
      "array",
      "binary_search"
    ],
    "solution": "### Observations\nThe array is \"partially\" sorted. If `nums[mid] > nums[high]`, it means the pivot (minimum) is in the right half (because the left side is sorted and greater than the far right). If `nums[mid] < nums[high]`, the right side is sorted, so the minimum is either at `mid` or to the left.\n\n### Approach\n1. `low = 0`, `high = n - 1`.\n2. Loop while `low < high`.\n3. `mid = (low + high) / 2`.\n4. Compare `nums[mid]` with `nums[high]`:\n   - If `nums[mid] > nums[high]`: Smallest value is to the right. `low = mid + 1`.\n   - If `nums[mid] < nums[high]`: Smallest value is at `mid` or left. `high = mid`.\n5. When loop ends, `nums[low]` is the minimum.\n\n### Complexity Analysis\n* **Time:** $O(\\log n)$.\n* **Space:** $O(1)$.\n\n### Code Logic (Java)\n```java\nwhile (low < high) {\n    int mid = low + (high - low) / 2;\n    if (nums[mid] > nums[high]) {\n        low = mid + 1;\n    } else {\n        high = mid;\n    }\n}\nreturn nums[low];\n```",
    "hints": [
      "If the array is not rotated (e.g., [1, 2, 3]), nums[low] < nums[high].",
      "Compare the middle element with the last element.",
      "If mid > last, the disruption is to the right.",
      "If mid < last, the right half is sorted, so the minimum is at mid or to the left."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    iterator = iter(input_data)\n    try:\n        n = int(next(iterator))\n        nums = [int(next(iterator)) for _ in range(n)]\n    except StopIteration:\n        return\n\n    # Write logic here\n    # print(min_val)\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if(!sc.hasNext()) return;\n        int n = sc.nextInt();\n        int[] nums = new int[n];\n        for(int i=0; i<n; i++) nums[i] = sc.nextInt();\n        \n        // Write logic here\n        // System.out.println(result);\n    }\n}",
    "test_cases": [
      {
        "input_data": "5\n3 4 5 1 2",
        "expected_output": "1",
        "is_public": true
      },
      {
        "input_data": "7\n4 5 6 7 0 1 2",
        "expected_output": "0",
        "is_public": true
      },
      {
        "input_data": "4\n11 13 15 17",
        "expected_output": "11",
        "is_public": true
      },
      {
        "input_data": "1\n5",
        "expected_output": "5",
        "is_public": false
      },
      {
        "input_data": "2\n2 1",
        "expected_output": "1",
        "is_public": false
      },
      {
        "input_data": "3\n3 1 2",
        "expected_output": "1",
        "is_public": false
      }
    ]
  },
  {
    "id": 875,
    "title": "Koko Eating Bananas",
    "description": "Koko loves to eat bananas. There are `n` piles of bananas, the `i-th` pile has `piles[i]` bananas. The guards have gone and will come back in `h` hours.\n\nKoko can decide her bananas-per-hour eating speed of `k`. Each hour, she chooses some pile of bananas and eats `k` bananas from that pile. If the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.\n\nReturn the minimum integer `k` such that she can eat all the bananas within `h` hours.",
    "input_format": "First line: N (number of piles).\nSecond line: N space-separated integers (piles).\nThird line: Integer H (hours).",
    "output_format": "Print the minimum integer k.",
    "difficulty": "Medium",
    "tags": [
      "array",
      "binary_search"
    ],
    "solution": "### Observations\nWe need to find the minimum speed `k`. \n* If Koko eats at speed 1, it takes $\\sum piles$ hours (too slow).\n* If Koko eats at speed `max(piles)`, it takes `N` hours (very fast).\n\nThe possible values of `k` range from `1` to `max(piles)`. This range is sorted (higher speed = less time). We can use Binary Search on the answer `k`.\n\n### Approach\n1. **Range:** `low = 1`, `high = max(piles)`.\n2. **Check Function:** For a given speed `mid`, calculate total hours needed: `sum(ceil(pile / mid))`.\n3. **Logic:**\n   - If `hours_needed <= h`: This speed works, try smaller (`high = mid - 1`, store `ans = mid`).\n   - If `hours_needed > h`: Too slow, increase speed (`low = mid + 1`).\n\n### Complexity Analysis\n* **Time:** $O(N \\log M)$ where $M$ is the max pile size.\n* **Space:** $O(1)$.\n\n### Code Logic (Python)\n```python\nimport math\n\ndef check(k, piles):\n    hours = 0\n    for p in piles:\n        hours += math.ceil(p / k)\n    return hours\n\nlow, high = 1, max(piles)\nans = high\nwhile low <= high:\n    mid = (low + high) // 2\n    if check(mid, piles) <= h:\n        ans = mid\n        high = mid - 1\n    else:\n        low = mid + 1\nreturn ans\n```",
    "hints": [
      "The speed k is inversely proportional to the time taken.",
      "The minimum possible speed is 1, the maximum useful speed is the size of the largest pile.",
      "Use Binary Search on the range [1, max(piles)].",
      "For a specific speed, iterate through the piles to calculate total hours required."
    ],
    "boilerplate_python": "import sys\nimport math\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    iterator = iter(input_data)\n    try:\n        n = int(next(iterator))\n        piles = [int(next(iterator)) for _ in range(n)]\n        h = int(next(iterator))\n    except StopIteration:\n        return\n\n    # Write logic here\n    # print(min_k)\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if(!sc.hasNext()) return;\n        int n = sc.nextInt();\n        int[] piles = new int[n];\n        for(int i=0; i<n; i++) piles[i] = sc.nextInt();\n        int h = sc.nextInt();\n        \n        // Write logic here\n        // System.out.println(ans);\n    }\n}",
    "test_cases": [
      {
        "input_data": "4\n3 6 7 11\n8",
        "expected_output": "4",
        "is_public": true
      },
      {
        "input_data": "5\n30 11 23 4 20\n5",
        "expected_output": "30",
        "is_public": true
      },
      {
        "input_data": "5\n30 11 23 4 20\n6",
        "expected_output": "23",
        "is_public": true
      },
      {
        "input_data": "1\n1000000000\n2",
        "expected_output": "500000000",
        "is_public": false
      },
      {
        "input_data": "3\n1 1 1\n3",
        "expected_output": "1",
        "is_public": false
      },
      {
        "input_data": "3\n1 1 1\n1000",
        "expected_output": "1",
        "is_public": false
      }
    ]
  },
  {
    "id": 1011,
    "title": "Capacity To Ship Packages Within D Days",
    "description": "A conveyor belt has packages that must be shipped from one port to another within `days` days.\n\nThe `i-th` package on the conveyor belt has a weight of `weights[i]`. Each day, we load the ship with packages on the conveyor belt (in the order given by `weights`). We may not load more weight than the maximum weight capacity of the ship.\n\nReturn the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within `days` days.",
    "input_format": "First line: N (number of packages).\nSecond line: N space-separated weights.\nThird line: Integer D (days).",
    "output_format": "Print the minimum capacity.",
    "difficulty": "Medium",
    "tags": [
      "array",
      "binary_search"
    ],
    "solution": "### Observations\nWe need to find a minimum capacity. \n- Minimum possible capacity must be at least `max(weights)` (must carry the heaviest item).\n- Maximum necessary capacity is `sum(weights)` (carry everything in 1 day).\n\nSince monotonicity holds (higher capacity -> fewer days), we can Binary Search on the capacity.\n\n### Approach\n1. `low = max(weights)`, `high = sum(weights)`.\n2. **Check Function:** For capacity `cap`, iterate through weights adding them to a current load. If `current + w > cap`, increment days used and reset `current = w`.\n3. If `days_needed <= D`: Capacity is sufficient, try smaller (`high = mid`).\n4. If `days_needed > D`: Capacity too small, increase (`low = mid + 1`).\n\n### Complexity Analysis\n* **Time:** $O(N \\log(\\sum weights))$.\n* **Space:** $O(1)$.\n\n### Code Logic (Java)\n```java\nint left = maxWeight, right = totalWeight;\nwhile (left < right) {\n    int mid = left + (right - left) / 2;\n    int daysNeeded = 1, currentLoad = 0;\n    for (int w : weights) {\n        if (currentLoad + w > mid) {\n            daysNeeded++;\n            currentLoad = 0;\n        }\n        currentLoad += w;\n    }\n    if (daysNeeded <= D) right = mid;\n    else left = mid + 1;\n}\nreturn left;\n```",
    "hints": [
      "The capacity must be at least the maximum weight of a single package.",
      "The capacity can be at most the sum of all weights.",
      "Use Binary Search on the range [max(weight), sum(weight)].",
      "Greedily fill the ship each day to see how many days a specific capacity requires."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    iterator = iter(input_data)\n    try:\n        n = int(next(iterator))\n        weights = [int(next(iterator)) for _ in range(n)]\n        days = int(next(iterator))\n    except StopIteration:\n        return\n\n    # Write logic here\n    # print(capacity)\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if(!sc.hasNext()) return;\n        int n = sc.nextInt();\n        int[] weights = new int[n];\n        for(int i=0; i<n; i++) weights[i] = sc.nextInt();\n        int days = sc.nextInt();\n        \n        // Write logic here\n        // System.out.println(capacity);\n    }\n}",
    "test_cases": [
      {
        "input_data": "10\n1 2 3 4 5 6 7 8 9 10\n5",
        "expected_output": "15",
        "is_public": true
      },
      {
        "input_data": "6\n3 2 2 4 1 4\n3",
        "expected_output": "6",
        "is_public": true
      },
      {
        "input_data": "5\n1 2 3 1 1\n4",
        "expected_output": "3",
        "is_public": true
      },
      {
        "input_data": "1\n10\n1",
        "expected_output": "10",
        "is_public": false
      },
      {
        "input_data": "3\n10 10 10\n3",
        "expected_output": "10",
        "is_public": false
      },
      {
        "input_data": "3\n10 50 10\n2",
        "expected_output": "60",
        "is_public": false
      }
    ]
  },
  {
    "id": 410,
    "title": "Split Array Largest Sum",
    "description": "Given an integer array **nums** and an integer **k**, split **nums** into **k** non-empty subarrays such that the largest sum of any subarray is minimized.\n\nReturn the minimized largest sum of the split.",
    "input_format": "First line: N (array size).\nSecond line: N space-separated integers.\nThird line: Integer k.",
    "output_format": "Print the result integer.",
    "difficulty": "Hard",
    "tags": [
      "array",
      "binary_search",
      "dp"
    ],
    "solution": "### Observations\nThis is identical to the \"Capacity to Ship Packages\" problem. We want to find a maximum subarray sum `S` such that we can split the array into `k` parts where no part exceeds `S`. \n\n### Approach\n1. **Range:** `low = max(nums)`, `high = sum(nums)`.\n2. **Check:** Can we split `nums` into $\\le k$ subarrays such that every subarray sum is $\\le mid$?\n3. Iterate through `nums`, accumulating sum. If `sum + current > mid`, start a new subarray. Count subarrays.\n4. If count $\\le k$, we can achieve this (maybe even smaller max sum), so `high = mid`.\n5. Else, we need larger sums, so `low = mid + 1`.\n\n### Complexity Analysis\n* **Time:** $O(N \\log(\\sum nums))$.\n* **Space:** $O(1)$.\n\n### Code Logic (Python)\n```python\ndef can_split(limit, nums, k):\n    count = 1\n    current_sum = 0\n    for x in nums:\n        if current_sum + x > limit:\n            count += 1\n            current_sum = x\n        else:\n            current_sum += x\n    return count <= k\n\nl, r = max(nums), sum(nums)\nwhile l < r:\n    mid = (l + r) // 2\n    if can_split(mid, nums, k):\n        r = mid\n    else:\n        l = mid + 1\nreturn l\n```",
    "hints": [
      "The problem asks to minimize the maximum sum.",
      "If the max sum is very large, we need few splits. If small, we need many splits.",
      "Binary search on the answer (the largest sum allowed).",
      "Lower bound is max element, upper bound is total sum."
    ],
    "boilerplate_python": "import sys\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    iterator = iter(input_data)\n    try:\n        n = int(next(iterator))\n        nums = [int(next(iterator)) for _ in range(n)]\n        k = int(next(iterator))\n    except StopIteration:\n        return\n\n    # Write logic here\n    # print(result)\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if(!sc.hasNext()) return;\n        int n = sc.nextInt();\n        int[] nums = new int[n];\n        for(int i=0; i<n; i++) nums[i] = sc.nextInt();\n        int k = sc.nextInt();\n        \n        // Write logic here\n        // System.out.println(result);\n    }\n}",
    "test_cases": [
      {
        "input_data": "5\n7 2 5 10 8\n2",
        "expected_output": "18",
        "is_public": true
      },
      {
        "input_data": "5\n1 2 3 4 5\n2",
        "expected_output": "9",
        "is_public": true
      },
      {
        "input_data": "5\n1 4 4 4 1\n3",
        "expected_output": "4",
        "is_public": true
      },
      {
        "input_data": "1\n10\n1",
        "expected_output": "10",
        "is_public": false
      },
      {
        "input_data": "3\n5 5 5\n3",
        "expected_output": "5",
        "is_public": false
      },
      {
        "input_data": "3\n1 2 3\n1",
        "expected_output": "6",
        "is_public": false
      }
    ]
  },
  {
    "id": 1283,
    "title": "Find the Smallest Divisor Given a Threshold",
    "description": "Given an array of integers **nums** and an integer **threshold**, we will choose a positive integer `divisor`, divide all the array by it, and sum the division's result. Find the **smallest** `divisor` such that the result of the sum is less than or equal to **threshold**.\n\nEach result of the division is rounded to the nearest integer greater than or equal to that element. (For example: 7/3 = 3 and 10/2 = 5).",
    "input_format": "First line: N (array size).\nSecond line: N space-separated integers.\nThird line: Integer threshold.",
    "output_format": "Print the smallest divisor.",
    "difficulty": "Medium",
    "tags": [
      "array",
      "binary_search"
    ],
    "solution": "### Observations\n1. As the divisor increases, the sum of results decreases. This monotonicity suggests Binary Search.\n2. The range of divisors is `[1, max(nums)]`. (Actually, `max(nums)` gives sum equal to size `N`. If `threshold < N`, no solution exists, but problem constraints usually guarantee a solution or `threshold >= N`).\n\n### Approach\n1. `low = 1`, `high = max(nums)` (or a sufficiently large number like 10^6).\n2. **Loop:** `while low < high`.\n3. `mid = (low + high) / 2`.\n4. **Calculate Sum:** `sum = Σ ceil(x / mid)`.\n5. If `sum <= threshold`: This divisor works, try smaller. `high = mid`.\n6. If `sum > threshold`: Sum is too big, need larger divisor. `low = mid + 1`.\n\n### Complexity Analysis\n* **Time:** $O(N \\log(\\max(nums)))$.\n* **Space:** $O(1)$.\n\n### Code Logic (Java)\n```java\nint left = 1, right = 1000000; // or max(nums)\nwhile (left < right) {\n    int mid = left + (right - left) / 2;\n    int sum = 0;\n    for (int num : nums) {\n        sum += (num + mid - 1) / mid; // Equivalent to ceil(num/mid)\n    }\n    if (sum <= threshold) right = mid;\n    else left = mid + 1;\n}\nreturn left;\n```",
    "hints": [
      "If the divisor is 1, the sum is the sum of all elements.",
      "If the divisor is very large, the sum becomes the length of the array.",
      "The function f(divisor) = sum is monotonically decreasing.",
      "Use (num + div - 1) / div to compute ceil(num / div) using integer arithmetic."
    ],
    "boilerplate_python": "import sys\nimport math\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    iterator = iter(input_data)\n    try:\n        n = int(next(iterator))\n        nums = [int(next(iterator)) for _ in range(n)]\n        threshold = int(next(iterator))\n    except StopIteration:\n        return\n\n    # Write logic here\n    # print(result)\n\nif __name__ == '__main__':\n    solve()",
    "boilerplate_java": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if(!sc.hasNext()) return;\n        int n = sc.nextInt();\n        int[] nums = new int[n];\n        for(int i=0; i<n; i++) nums[i] = sc.nextInt();\n        int threshold = sc.nextInt();\n        \n        // Write logic here\n        // System.out.println(result);\n    }\n}",
    "test_cases": [
      {
        "input_data": "4\n1 2 5 9\n6",
        "expected_output": "5",
        "is_public": true
      },
      {
        "input_data": "5\n44 22 33 11 1\n5",
        "expected_output": "44",
        "is_public": true
      },
      {
        "input_data": "4\n2 3 5 7\n11",
        "expected_output": "3",
        "is_public": true
      },
      {
        "input_data": "1\n19\n5",
        "expected_output": "4",
        "is_public": false
      },
      {
        "input_data": "3\n1 1 1\n3",
        "expected_output": "1",
        "is_public": false
      },
      {
        "input_data": "2\n10 10\n100",
        "expected_output": "1",
        "is_public": false
      }
    ]
  }
]